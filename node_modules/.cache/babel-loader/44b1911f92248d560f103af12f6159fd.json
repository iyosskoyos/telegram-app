{"ast":null,"code":"var _jsxFileName = \"/home/me-admin/Downloads/my-app/src/Components/ColumnLeft/DialogsList.js\";\n\n/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport React from 'react';\nimport Dialog from '../Tile/Dialog';\nimport DialogPlaceholder from '../Tile/DialogPlaceholder';\nimport { CHAT_SLICE_LIMIT } from '../../Constants';\nimport { loadChatsContent } from '../../Utils/File';\nimport { orderCompare } from '../../Utils/Common';\nimport ChatStore from '../../Stores/ChatStore';\nimport BasicGroupStore from '../../Stores/BasicGroupStore';\nimport SupergroupStore from '../../Stores/SupergroupStore';\nimport ApplicationStore from '../../Stores/ApplicationStore';\nimport FileStore from '../../Stores/FileStore';\nimport TdLibController from '../../Controllers/TdLibController';\nimport './DialogsList.css';\n\nclass DialogsList extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.onClientUpdateLeaveChat = update => {\n      if (update.inProgress) {\n        this.hiddenChats.set(update.chatId, update.chatId);\n      } else {\n        this.hiddenChats.delete(update.chatId);\n      }\n\n      this.forceUpdate();\n    };\n\n    this.onUpdateAuthorizationState = update => {\n      const authorization_state = update.authorization_state;\n      this.setState({\n        authorizationState: authorization_state\n      }, () => this.loadFirstSlice());\n    };\n\n    this.onFastUpdatingComplete = update => {\n      this.onLoadNext(true); // this.setState({ chats: [] }, () => this.onLoadNext(true));\n    };\n\n    this.onUpdateConnectionState = update => {\n      const newConnectionState = update.state;\n      const connectionState = this.state.connectionState;\n      this.setState({\n        connectionState: newConnectionState\n      });\n      const updatingCompleted = connectionState && connectionState['@type'] === 'connectionStateUpdating' && newConnectionState['@type'] !== 'connectionStateUpdating';\n      if (!updatingCompleted) return;\n      const hasSkippedUpdates = ChatStore.skippedUpdates.length > 0;\n      if (!hasSkippedUpdates) return;\n      ChatStore.skippedUpdates = [];\n      this.setState({\n        chats: []\n      }, () => this.onLoadNext(true));\n    };\n\n    this.loadFirstSlice = async () => {\n      const authorizationState = this.state.authorizationState;\n\n      if (authorizationState && authorizationState['@type'] === 'authorizationStateReady') {\n        await FileStore.initDB(() => this.onLoadNext());\n      }\n    };\n\n    this.onUpdateChatOrder = update => {\n      // NOTE: updateChatOrder is primary used to delete chats with order=0\n      // In all other cases use updateChatLastMessage\n      if (update.order !== '0') return;\n      const chat = ChatStore.get(update.chat_id);\n\n      if (!chat) {\n        return;\n      } // unselect deleted chat\n\n\n      if (update.chat_id === ApplicationStore.getChatId()) {\n        TdLibController.setChatId(0);\n        ApplicationStore.changeChatDetailsVisibility(false);\n      }\n\n      let chatIds = [];\n\n      for (let i = 0; i < this.state.chats.length; i++) {\n        let chat = ChatStore.get(this.state.chats[i]);\n\n        if (chat && chat.order !== '0') {\n          switch (chat.type['@type']) {\n            case 'chatTypeBasicGroup':\n              {\n                const basicGroup = BasicGroupStore.get(chat.type.basic_group_id);\n\n                if (basicGroup.status['@type'] !== 'chatMemberStatusLeft') {\n                  chatIds.push(chat.id);\n                }\n\n                break;\n              }\n\n            case 'chatTypePrivate':\n              {\n                chatIds.push(chat.id);\n                break;\n              }\n\n            case 'chatTypeSecret':\n              {\n                chatIds.push(chat.id);\n                break;\n              }\n\n            case 'chatTypeSupergroup':\n              {\n                const supergroup = SupergroupStore.get(chat.type.supergroup_id);\n\n                if (supergroup.status['@type'] !== 'chatMemberStatusLeft') {\n                  chatIds.push(chat.id);\n                }\n\n                break;\n              }\n          }\n        }\n      }\n\n      this.reorderChats(chatIds);\n    };\n\n    this.onUpdate = update => {\n      const chat_id = update.chat_id,\n            order = update.order;\n      if (order === '0') return;\n      const chat = ChatStore.get(chat_id);\n\n      if (!chat || chat.order === '0') {\n        return;\n      }\n\n      const chats = this.state.chats;\n      let newChatIds = [];\n\n      if (chats.length > 0) {\n        const existingChat = chats.find(x => x === chat_id);\n\n        if (!existingChat) {\n          const minChatOrder = ChatStore.get(chats[chats.length - 1]).order;\n\n          if (orderCompare(minChatOrder, chat.order) === 1) {\n            return;\n          }\n\n          newChatIds.push(chat.id);\n        }\n      } // get last chat.order values\n\n\n      let chatIds = [];\n\n      for (let i = 0; i < chats.length; i++) {\n        let chat = ChatStore.get(chats[i]);\n\n        if (chat && chat.order !== '0') {\n          switch (chat.type['@type']) {\n            case 'chatTypeBasicGroup':\n              {\n                const basicGroup = BasicGroupStore.get(chat.type.basic_group_id);\n\n                if (basicGroup.status['@type'] !== 'chatMemberStatusLeft') {\n                  chatIds.push(chat.id);\n                }\n\n                break;\n              }\n\n            case 'chatTypePrivate':\n              {\n                chatIds.push(chat.id);\n                break;\n              }\n\n            case 'chatTypeSecret':\n              {\n                chatIds.push(chat.id);\n                break;\n              }\n\n            case 'chatTypeSupergroup':\n              {\n                const supergroup = SupergroupStore.get(chat.type.supergroup_id);\n\n                if (supergroup.status['@type'] !== 'chatMemberStatusLeft') {\n                  chatIds.push(chat.id);\n                }\n\n                break;\n              }\n          }\n        }\n      }\n\n      this.reorderChats(chatIds, newChatIds, () => {\n        this.loadChatContents(newChatIds);\n      });\n    };\n\n    this.handleScroll = () => {\n      const list = this.listRef.current;\n\n      if (list && list.scrollTop + list.offsetHeight >= list.scrollHeight) {\n        this.onLoadNext();\n      }\n    };\n\n    this.onLoadNext = async (replace = false) => {\n      const chats = this.state.chats;\n      if (this.loading) return;\n      let offsetOrder = '9223372036854775807'; // 2^63 - 1\n\n      let offsetChatId = 0;\n\n      if (!replace && chats && chats.length > 0) {\n        const chat = ChatStore.get(chats[chats.length - 1]);\n\n        if (chat) {\n          offsetOrder = chat.order;\n          offsetChatId = chat.id;\n        }\n      }\n\n      console.log('DialogsList.onLoadNext getChats start', offsetChatId, offsetOrder);\n      this.loading = true;\n      const result = await TdLibController.send({\n        '@type': 'getChats',\n        offset_chat_id: offsetChatId,\n        offset_order: offsetOrder,\n        limit: CHAT_SLICE_LIMIT\n      }).finally(() => {\n        this.loading = false;\n        TdLibController.clientUpdate({\n          '@type': 'clientUpdateDialogsReady'\n        });\n      });\n      console.log('DialogsList.onLoadNext getChats stop', offsetChatId, offsetOrder); // TdLibController.send({\n      //     '@type': 'getChats',\n      //     offset_chat_id: offsetChatId,\n      //     offset_order: offsetOrder,\n      //     limit: CHAT_SLICE_LIMIT + 100\n      // });\n\n      if (result.chat_ids.length > 0 && result.chat_ids[0] === offsetChatId) {\n        result.chat_ids.shift();\n      }\n\n      if (replace) {\n        this.replaceChats(result.chat_ids, () => {\n          this.loadChatContents(result.chat_ids);\n        });\n      } else {\n        console.log('DialogsList.onLoadNext setState start', offsetChatId, offsetOrder);\n        this.appendChats(result.chat_ids, () => {\n          console.log('DialogsList.onLoadNext setState stop', offsetChatId, offsetOrder);\n          this.loadChatContents(result.chat_ids);\n        });\n      }\n    };\n\n    this.hiddenChats = new Map();\n    this.listRef = React.createRef();\n    this.state = {\n      chats: [],\n      authorizationState: ApplicationStore.getAuthorizationState(),\n      connectionState: ApplicationStore.getConnectionState(),\n      fistSliceLoaded: false\n    };\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (nextState.chats !== this.state.chats) {\n      return true;\n    }\n\n    if (nextState.firstSliceLoaded !== this.state.firstSliceLoaded) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    const list = this.listRef.current;\n    return {\n      scrollTop: list.scrollTop\n    };\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    const list = this.listRef.current;\n    const scrollTop = snapshot.scrollTop;\n    list.scrollTop = scrollTop;\n  }\n\n  componentDidMount() {\n    this.loadFirstSlice();\n    ApplicationStore.on('updateAuthorizationState', this.onUpdateAuthorizationState); // ApplicationStore.on('updateConnectionState', this.onUpdateConnectionState);\n\n    ChatStore.on('clientUpdateFastUpdatingComplete', this.onFastUpdatingComplete);\n    ChatStore.on('updateChatDraftMessage', this.onUpdate);\n    ChatStore.on('updateChatIsPinned', this.onUpdate);\n    ChatStore.on('updateChatLastMessage', this.onUpdate);\n    ChatStore.on('updateChatOrder', this.onUpdateChatOrder);\n    ChatStore.on('clientUpdateLeaveChat', this.onClientUpdateLeaveChat);\n  }\n\n  componentWillUnmount() {\n    ApplicationStore.removeListener('updateAuthorizationState', this.onUpdateAuthorizationState); // ApplicationStore.removeListener('updateConnectionState', this.onUpdateConnectionState);\n\n    ChatStore.removeListener('clientUpdateFastUpdatingComplete', this.onFastUpdatingComplete);\n    ChatStore.removeListener('updateChatDraftMessage', this.onUpdate);\n    ChatStore.removeListener('updateChatIsPinned', this.onUpdate);\n    ChatStore.removeListener('updateChatLastMessage', this.onUpdate);\n    ChatStore.removeListener('updateChatOrder', this.onUpdateChatOrder);\n    ChatStore.removeListener('clientUpdateLeaveChat', this.onClientUpdateLeaveChat);\n  }\n\n  reorderChats(chatIds, newChatIds = [], callback) {\n    const orderedChatIds = chatIds.concat(newChatIds).sort((a, b) => {\n      return orderCompare(ChatStore.get(b).order, ChatStore.get(a).order);\n    });\n\n    if (!DialogsList.isDifferentOrder(this.state.chats, orderedChatIds)) {\n      return;\n    }\n\n    this.setState({\n      chats: orderedChatIds\n    }, callback);\n  }\n\n  static isDifferentOrder(oldChatIds, newChatIds) {\n    if (oldChatIds.length === newChatIds.length) {\n      for (let i = 0; i < oldChatIds.length; i++) {\n        if (oldChatIds[i] !== newChatIds[i]) return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  loadChatContents(chats) {\n    const store = FileStore.getStore();\n    loadChatsContent(store, chats);\n  }\n\n  appendChats(chats, callback) {\n    if (chats.length === 0) return;\n    this.setState({\n      chats: this.state.chats.concat(chats),\n      firstSliceLoaded: true\n    }, callback);\n  }\n\n  replaceChats(chats, callback) {\n    this.setState({\n      chats: chats,\n      firstSliceLoaded: true\n    }, callback);\n  }\n\n  scrollToTop() {\n    const list = this.listRef.current;\n    list.scrollTop = 0;\n  }\n\n  render() {\n    const _this$state = this.state,\n          chats = _this$state.chats,\n          firstSliceLoaded = _this$state.firstSliceLoaded; // const dialogs = chats.map((x, index) => <DialogPlaceholder key={x} chatId={x} index={index} showTitle/>);\n\n    const dialogs = firstSliceLoaded ? chats.map(x => React.createElement(Dialog, {\n      key: x,\n      chatId: x,\n      hidden: this.hiddenChats.has(x),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 352\n      },\n      __self: this\n    })) : Array.from(Array(10)).map((x, index) => React.createElement(DialogPlaceholder, {\n      key: index,\n      index: index,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 353\n      },\n      __self: this\n    }));\n    return React.createElement(\"div\", {\n      ref: this.listRef,\n      className: \"dialogs-list\",\n      onScroll: this.handleScroll,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 356\n      },\n      __self: this\n    }, dialogs);\n  }\n\n}\n\nexport default DialogsList;","map":{"version":3,"sources":["/home/me-admin/Downloads/my-app/src/Components/ColumnLeft/DialogsList.js"],"names":["React","Dialog","DialogPlaceholder","CHAT_SLICE_LIMIT","loadChatsContent","orderCompare","ChatStore","BasicGroupStore","SupergroupStore","ApplicationStore","FileStore","TdLibController","DialogsList","Component","constructor","props","onClientUpdateLeaveChat","update","inProgress","hiddenChats","set","chatId","delete","forceUpdate","onUpdateAuthorizationState","authorization_state","setState","authorizationState","loadFirstSlice","onFastUpdatingComplete","onLoadNext","onUpdateConnectionState","newConnectionState","state","connectionState","updatingCompleted","hasSkippedUpdates","skippedUpdates","length","chats","initDB","onUpdateChatOrder","order","chat","get","chat_id","getChatId","setChatId","changeChatDetailsVisibility","chatIds","i","type","basicGroup","basic_group_id","status","push","id","supergroup","supergroup_id","reorderChats","onUpdate","newChatIds","existingChat","find","x","minChatOrder","loadChatContents","handleScroll","list","listRef","current","scrollTop","offsetHeight","scrollHeight","replace","loading","offsetOrder","offsetChatId","console","log","result","send","offset_chat_id","offset_order","limit","finally","clientUpdate","chat_ids","shift","replaceChats","appendChats","Map","createRef","getAuthorizationState","getConnectionState","fistSliceLoaded","shouldComponentUpdate","nextProps","nextState","firstSliceLoaded","getSnapshotBeforeUpdate","prevProps","prevState","componentDidUpdate","snapshot","componentDidMount","on","componentWillUnmount","removeListener","callback","orderedChatIds","concat","sort","a","b","isDifferentOrder","oldChatIds","store","getStore","scrollToTop","render","dialogs","map","has","Array","from","index"],"mappings":"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","sourcesContent":["/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React from 'react';\nimport Dialog from '../Tile/Dialog';\nimport DialogPlaceholder from '../Tile/DialogPlaceholder';\nimport { CHAT_SLICE_LIMIT } from '../../Constants';\nimport { loadChatsContent } from '../../Utils/File';\nimport { orderCompare } from '../../Utils/Common';\nimport ChatStore from '../../Stores/ChatStore';\nimport BasicGroupStore from '../../Stores/BasicGroupStore';\nimport SupergroupStore from '../../Stores/SupergroupStore';\nimport ApplicationStore from '../../Stores/ApplicationStore';\nimport FileStore from '../../Stores/FileStore';\nimport TdLibController from '../../Controllers/TdLibController';\nimport './DialogsList.css';\n\nclass DialogsList extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.hiddenChats = new Map();\n\n        this.listRef = React.createRef();\n\n        this.state = {\n            chats: [],\n            authorizationState: ApplicationStore.getAuthorizationState(),\n            connectionState: ApplicationStore.getConnectionState(),\n            fistSliceLoaded: false\n        };\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        if (nextState.chats !== this.state.chats) {\n            return true;\n        }\n\n        if (nextState.firstSliceLoaded !== this.state.firstSliceLoaded) {\n            return true;\n        }\n\n        return false;\n    }\n\n    getSnapshotBeforeUpdate(prevProps, prevState) {\n        const { current: list } = this.listRef;\n\n        return { scrollTop: list.scrollTop };\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        const { current: list } = this.listRef;\n        const { scrollTop } = snapshot;\n\n        list.scrollTop = scrollTop;\n    }\n\n    componentDidMount() {\n        this.loadFirstSlice();\n\n        ApplicationStore.on('updateAuthorizationState', this.onUpdateAuthorizationState);\n        // ApplicationStore.on('updateConnectionState', this.onUpdateConnectionState);\n        ChatStore.on('clientUpdateFastUpdatingComplete', this.onFastUpdatingComplete);\n        ChatStore.on('updateChatDraftMessage', this.onUpdate);\n        ChatStore.on('updateChatIsPinned', this.onUpdate);\n        ChatStore.on('updateChatLastMessage', this.onUpdate);\n        ChatStore.on('updateChatOrder', this.onUpdateChatOrder);\n        ChatStore.on('clientUpdateLeaveChat', this.onClientUpdateLeaveChat);\n    }\n\n    componentWillUnmount() {\n        ApplicationStore.removeListener('updateAuthorizationState', this.onUpdateAuthorizationState);\n        // ApplicationStore.removeListener('updateConnectionState', this.onUpdateConnectionState);\n        ChatStore.removeListener('clientUpdateFastUpdatingComplete', this.onFastUpdatingComplete);\n        ChatStore.removeListener('updateChatDraftMessage', this.onUpdate);\n        ChatStore.removeListener('updateChatIsPinned', this.onUpdate);\n        ChatStore.removeListener('updateChatLastMessage', this.onUpdate);\n        ChatStore.removeListener('updateChatOrder', this.onUpdateChatOrder);\n        ChatStore.removeListener('clientUpdateLeaveChat', this.onClientUpdateLeaveChat);\n    }\n\n    onClientUpdateLeaveChat = update => {\n        if (update.inProgress) {\n            this.hiddenChats.set(update.chatId, update.chatId);\n        } else {\n            this.hiddenChats.delete(update.chatId);\n        }\n\n        this.forceUpdate();\n    };\n\n    onUpdateAuthorizationState = update => {\n        const { authorization_state } = update;\n\n        this.setState({ authorizationState: authorization_state }, () => this.loadFirstSlice());\n    };\n\n    onFastUpdatingComplete = update => {\n        this.onLoadNext(true);\n        // this.setState({ chats: [] }, () => this.onLoadNext(true));\n    };\n\n    onUpdateConnectionState = update => {\n        const newConnectionState = update.state;\n        const { connectionState } = this.state;\n\n        this.setState({ connectionState: newConnectionState });\n\n        const updatingCompleted =\n            connectionState &&\n            connectionState['@type'] === 'connectionStateUpdating' &&\n            newConnectionState['@type'] !== 'connectionStateUpdating';\n        if (!updatingCompleted) return;\n\n        const hasSkippedUpdates = ChatStore.skippedUpdates.length > 0;\n        if (!hasSkippedUpdates) return;\n\n        ChatStore.skippedUpdates = [];\n        this.setState({ chats: [] }, () => this.onLoadNext(true));\n    };\n\n    loadFirstSlice = async () => {\n        const { authorizationState } = this.state;\n        if (authorizationState && authorizationState['@type'] === 'authorizationStateReady') {\n            await FileStore.initDB(() => this.onLoadNext());\n        }\n    };\n\n    onUpdateChatOrder = update => {\n        // NOTE: updateChatOrder is primary used to delete chats with order=0\n        // In all other cases use updateChatLastMessage\n\n        if (update.order !== '0') return;\n        const chat = ChatStore.get(update.chat_id);\n        if (!chat) {\n            return;\n        }\n\n        // unselect deleted chat\n        if (update.chat_id === ApplicationStore.getChatId()) {\n            TdLibController.setChatId(0);\n            ApplicationStore.changeChatDetailsVisibility(false);\n        }\n\n        let chatIds = [];\n        for (let i = 0; i < this.state.chats.length; i++) {\n            let chat = ChatStore.get(this.state.chats[i]);\n            if (chat && chat.order !== '0') {\n                switch (chat.type['@type']) {\n                    case 'chatTypeBasicGroup': {\n                        const basicGroup = BasicGroupStore.get(chat.type.basic_group_id);\n                        if (basicGroup.status['@type'] !== 'chatMemberStatusLeft') {\n                            chatIds.push(chat.id);\n                        }\n                        break;\n                    }\n                    case 'chatTypePrivate': {\n                        chatIds.push(chat.id);\n                        break;\n                    }\n                    case 'chatTypeSecret': {\n                        chatIds.push(chat.id);\n                        break;\n                    }\n                    case 'chatTypeSupergroup': {\n                        const supergroup = SupergroupStore.get(chat.type.supergroup_id);\n                        if (supergroup.status['@type'] !== 'chatMemberStatusLeft') {\n                            chatIds.push(chat.id);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        this.reorderChats(chatIds);\n    };\n\n    onUpdate = update => {\n        const { chat_id, order } = update;\n        if (order === '0') return;\n        const chat = ChatStore.get(chat_id);\n        if (!chat || chat.order === '0') {\n            return;\n        }\n\n        const { chats } = this.state;\n\n        let newChatIds = [];\n        if (chats.length > 0) {\n            const existingChat = chats.find(x => x === chat_id);\n            if (!existingChat) {\n                const minChatOrder = ChatStore.get(chats[chats.length - 1]).order;\n                if (orderCompare(minChatOrder, chat.order) === 1) {\n                    return;\n                }\n                newChatIds.push(chat.id);\n            }\n        }\n\n        // get last chat.order values\n        let chatIds = [];\n        for (let i = 0; i < chats.length; i++) {\n            let chat = ChatStore.get(chats[i]);\n            if (chat && chat.order !== '0') {\n                switch (chat.type['@type']) {\n                    case 'chatTypeBasicGroup': {\n                        const basicGroup = BasicGroupStore.get(chat.type.basic_group_id);\n                        if (basicGroup.status['@type'] !== 'chatMemberStatusLeft') {\n                            chatIds.push(chat.id);\n                        }\n                        break;\n                    }\n                    case 'chatTypePrivate': {\n                        chatIds.push(chat.id);\n                        break;\n                    }\n                    case 'chatTypeSecret': {\n                        chatIds.push(chat.id);\n                        break;\n                    }\n                    case 'chatTypeSupergroup': {\n                        const supergroup = SupergroupStore.get(chat.type.supergroup_id);\n                        if (supergroup.status['@type'] !== 'chatMemberStatusLeft') {\n                            chatIds.push(chat.id);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        this.reorderChats(chatIds, newChatIds, () => {\n            this.loadChatContents(newChatIds);\n        });\n    };\n\n    reorderChats(chatIds, newChatIds = [], callback) {\n        const orderedChatIds = chatIds.concat(newChatIds).sort((a, b) => {\n            return orderCompare(ChatStore.get(b).order, ChatStore.get(a).order);\n        });\n\n        if (!DialogsList.isDifferentOrder(this.state.chats, orderedChatIds)) {\n            return;\n        }\n\n        this.setState({ chats: orderedChatIds }, callback);\n    }\n\n    static isDifferentOrder(oldChatIds, newChatIds) {\n        if (oldChatIds.length === newChatIds.length) {\n            for (let i = 0; i < oldChatIds.length; i++) {\n                if (oldChatIds[i] !== newChatIds[i]) return true;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    handleScroll = () => {\n        const list = this.listRef.current;\n\n        if (list && list.scrollTop + list.offsetHeight >= list.scrollHeight) {\n            this.onLoadNext();\n        }\n    };\n\n    onLoadNext = async (replace = false) => {\n        const { chats } = this.state;\n\n        if (this.loading) return;\n\n        let offsetOrder = '9223372036854775807'; // 2^63 - 1\n        let offsetChatId = 0;\n        if (!replace && chats && chats.length > 0) {\n            const chat = ChatStore.get(chats[chats.length - 1]);\n            if (chat) {\n                offsetOrder = chat.order;\n                offsetChatId = chat.id;\n            }\n        }\n\n        console.log('DialogsList.onLoadNext getChats start', offsetChatId, offsetOrder);\n        this.loading = true;\n        const result = await TdLibController.send({\n            '@type': 'getChats',\n            offset_chat_id: offsetChatId,\n            offset_order: offsetOrder,\n            limit: CHAT_SLICE_LIMIT\n        }).finally(() => {\n            this.loading = false;\n            TdLibController.clientUpdate({ '@type': 'clientUpdateDialogsReady' });\n        });\n        console.log('DialogsList.onLoadNext getChats stop', offsetChatId, offsetOrder);\n        // TdLibController.send({\n        //     '@type': 'getChats',\n        //     offset_chat_id: offsetChatId,\n        //     offset_order: offsetOrder,\n        //     limit: CHAT_SLICE_LIMIT + 100\n        // });\n\n        if (result.chat_ids.length > 0 && result.chat_ids[0] === offsetChatId) {\n            result.chat_ids.shift();\n        }\n\n        if (replace) {\n            this.replaceChats(result.chat_ids, () => {\n                this.loadChatContents(result.chat_ids);\n            });\n        } else {\n            console.log('DialogsList.onLoadNext setState start', offsetChatId, offsetOrder);\n            this.appendChats(result.chat_ids, () => {\n                console.log('DialogsList.onLoadNext setState stop', offsetChatId, offsetOrder);\n                this.loadChatContents(result.chat_ids);\n            });\n        }\n    };\n\n    loadChatContents(chats) {\n        const store = FileStore.getStore();\n        loadChatsContent(store, chats);\n    }\n\n    appendChats(chats, callback) {\n        if (chats.length === 0) return;\n\n        this.setState({ chats: this.state.chats.concat(chats), firstSliceLoaded: true }, callback);\n    }\n\n    replaceChats(chats, callback) {\n        this.setState({ chats: chats, firstSliceLoaded: true }, callback);\n    }\n\n    scrollToTop() {\n        const list = this.listRef.current;\n        list.scrollTop = 0;\n    }\n\n    render() {\n        const { chats, firstSliceLoaded } = this.state;\n\n        // const dialogs = chats.map((x, index) => <DialogPlaceholder key={x} chatId={x} index={index} showTitle/>);\n\n        const dialogs = firstSliceLoaded\n            ? chats.map(x => <Dialog key={x} chatId={x} hidden={this.hiddenChats.has(x)} />)\n            : Array.from(Array(10)).map((x, index) => <DialogPlaceholder key={index} index={index} />);\n\n        return (\n            <div ref={this.listRef} className='dialogs-list' onScroll={this.handleScroll}>\n                {dialogs}\n            </div>\n        );\n    }\n}\n\nexport default DialogsList;\n"]},"metadata":{},"sourceType":"module"}