{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"tdweb\", [], factory);else if (typeof exports === 'object') exports[\"tdweb\"] = factory();else root[\"tdweb\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 9);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      module.exports = __webpack_require__(13);\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports) {\n      module.exports = false;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          Promise.resolve(value).then(_next, _throw);\n        }\n      }\n\n      function _asyncToGenerator(fn) {\n        return function () {\n          var self = this,\n              args = arguments;\n          return new Promise(function (resolve, reject) {\n            var gen = fn.apply(self, args);\n\n            function _next(value) {\n              asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n\n            function _throw(err) {\n              asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n\n            _next(undefined);\n          });\n        };\n      }\n\n      module.exports = _asyncToGenerator;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      module.exports = _classCallCheck;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      module.exports = _createClass;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      function _typeof2(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof2 = function _typeof2(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof2 = function _typeof2(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof2(obj);\n      }\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n          module.exports = _typeof = function _typeof(obj) {\n            return _typeof2(obj);\n          };\n        } else {\n          module.exports = _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      module.exports = _typeof;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var arrayWithHoles = __webpack_require__(10);\n\n      var iterableToArrayLimit = __webpack_require__(11);\n\n      var nonIterableRest = __webpack_require__(12);\n\n      function _slicedToArray(arr, i) {\n        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n      }\n\n      module.exports = _slicedToArray;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      module.exports = function () {\n        return new Worker(__webpack_require__.p + \"2380cfa0e562e148fa50.worker.js\");\n      };\n      /***/\n\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var rng = __webpack_require__(15);\n\n      var bytesToUuid = __webpack_require__(16);\n\n      function v4(options, buf, offset) {\n        var i = buf && offset || 0;\n\n        if (typeof options == 'string') {\n          buf = options === 'binary' ? new Array(16) : null;\n          options = null;\n        }\n\n        options = options || {};\n        var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n        rnds[6] = rnds[6] & 0x0f | 0x40;\n        rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n        if (buf) {\n          for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n          }\n        }\n\n        return buf || bytesToUuid(rnds);\n      }\n\n      module.exports = v4;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      module.exports = __webpack_require__(17);\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports) {\n      function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n\n      module.exports = _arrayWithHoles;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports) {\n      function _iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      module.exports = _iterableToArrayLimit;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports) {\n      function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      module.exports = _nonIterableRest;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright (c) 2014-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       */\n      var runtime = function (exports) {\n        \"use strict\";\n\n        var Op = Object.prototype;\n        var hasOwn = Op.hasOwnProperty;\n        var undefined; // More compressible than void 0.\n\n        var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n        var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n        var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n        var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n        function wrap(innerFn, outerFn, self, tryLocsList) {\n          // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n          var generator = Object.create(protoGenerator.prototype);\n          var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n          // .throw, and .return methods.\n\n          generator._invoke = makeInvokeMethod(innerFn, self, context);\n          return generator;\n        }\n\n        exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n        // record like context.tryEntries[i].completion. This interface could\n        // have been (and was previously) designed to take a closure to be\n        // invoked without arguments, but in all the cases we care about we\n        // already have an existing method we want to call, so there's no need\n        // to create a new function object. We can even get away with assuming\n        // the method takes exactly one argument, since that happens to be true\n        // in every case, so we don't have to touch the arguments object. The\n        // only additional allocation required is the completion record, which\n        // has a stable shape and so hopefully should be cheap to allocate.\n\n        function tryCatch(fn, obj, arg) {\n          try {\n            return {\n              type: \"normal\",\n              arg: fn.call(obj, arg)\n            };\n          } catch (err) {\n            return {\n              type: \"throw\",\n              arg: err\n            };\n          }\n        }\n\n        var GenStateSuspendedStart = \"suspendedStart\";\n        var GenStateSuspendedYield = \"suspendedYield\";\n        var GenStateExecuting = \"executing\";\n        var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n        // breaking out of the dispatch switch statement.\n\n        var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n        // .constructor.prototype properties for functions that return Generator\n        // objects. For full spec compliance, you may wish to configure your\n        // minifier not to mangle the names of these two functions.\n\n        function Generator() {}\n\n        function GeneratorFunction() {}\n\n        function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n        // don't natively support it.\n\n\n        var IteratorPrototype = {};\n\n        IteratorPrototype[iteratorSymbol] = function () {\n          return this;\n        };\n\n        var getProto = Object.getPrototypeOf;\n        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n          // This environment has a native %IteratorPrototype%; use it instead\n          // of the polyfill.\n          IteratorPrototype = NativeIteratorPrototype;\n        }\n\n        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n        GeneratorFunctionPrototype.constructor = GeneratorFunction;\n        GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n        // Iterator interface in terms of a single ._invoke method.\n\n        function defineIteratorMethods(prototype) {\n          [\"next\", \"throw\", \"return\"].forEach(function (method) {\n            prototype[method] = function (arg) {\n              return this._invoke(method, arg);\n            };\n          });\n        }\n\n        exports.isGeneratorFunction = function (genFun) {\n          var ctor = typeof genFun === \"function\" && genFun.constructor;\n          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n          // do is to check its .name property.\n          (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n        };\n\n        exports.mark = function (genFun) {\n          if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n          } else {\n            genFun.__proto__ = GeneratorFunctionPrototype;\n\n            if (!(toStringTagSymbol in genFun)) {\n              genFun[toStringTagSymbol] = \"GeneratorFunction\";\n            }\n          }\n\n          genFun.prototype = Object.create(Gp);\n          return genFun;\n        }; // Within the body of any async function, `await x` is transformed to\n        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n        // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n        // meant to be awaited.\n\n\n        exports.awrap = function (arg) {\n          return {\n            __await: arg\n          };\n        };\n\n        function AsyncIterator(generator) {\n          function invoke(method, arg, resolve, reject) {\n            var record = tryCatch(generator[method], generator, arg);\n\n            if (record.type === \"throw\") {\n              reject(record.arg);\n            } else {\n              var result = record.arg;\n              var value = result.value;\n\n              if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n                return Promise.resolve(value.__await).then(function (value) {\n                  invoke(\"next\", value, resolve, reject);\n                }, function (err) {\n                  invoke(\"throw\", err, resolve, reject);\n                });\n              }\n\n              return Promise.resolve(value).then(function (unwrapped) {\n                // When a yielded Promise is resolved, its final value becomes\n                // the .value of the Promise<{value,done}> result for the\n                // current iteration.\n                result.value = unwrapped;\n                resolve(result);\n              }, function (error) {\n                // If a rejected Promise was yielded, throw the rejection back\n                // into the async generator function so it can be handled there.\n                return invoke(\"throw\", error, resolve, reject);\n              });\n            }\n          }\n\n          var previousPromise;\n\n          function enqueue(method, arg) {\n            function callInvokeWithMethodAndArg() {\n              return new Promise(function (resolve, reject) {\n                invoke(method, arg, resolve, reject);\n              });\n            }\n\n            return previousPromise = // If enqueue has been called before, then we want to wait until\n            // all previous Promises have been resolved before calling invoke,\n            // so that results are always delivered in the correct order. If\n            // enqueue has not been called before, then it is important to\n            // call invoke immediately, without waiting on a callback to fire,\n            // so that the async generator function has the opportunity to do\n            // any necessary setup in a predictable way. This predictability\n            // is why the Promise constructor synchronously invokes its\n            // executor callback, and why async functions synchronously\n            // execute code before the first await. Since we implement simple\n            // async functions in terms of async generators, it is especially\n            // important to get this right, even though it requires care.\n            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n          } // Define the unified helper method that is used to implement .next,\n          // .throw, and .return (see defineIteratorMethods).\n\n\n          this._invoke = enqueue;\n        }\n\n        defineIteratorMethods(AsyncIterator.prototype);\n\n        AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n          return this;\n        };\n\n        exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n        // AsyncIterator objects; they just return a Promise for the value of\n        // the final result produced by the iterator.\n\n        exports.async = function (innerFn, outerFn, self, tryLocsList) {\n          var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n          return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n          : iter.next().then(function (result) {\n            return result.done ? result.value : iter.next();\n          });\n        };\n\n        function makeInvokeMethod(innerFn, self, context) {\n          var state = GenStateSuspendedStart;\n          return function invoke(method, arg) {\n            if (state === GenStateExecuting) {\n              throw new Error(\"Generator is already running\");\n            }\n\n            if (state === GenStateCompleted) {\n              if (method === \"throw\") {\n                throw arg;\n              } // Be forgiving, per 25.3.3.3.3 of the spec:\n              // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n              return doneResult();\n            }\n\n            context.method = method;\n            context.arg = arg;\n\n            while (true) {\n              var delegate = context.delegate;\n\n              if (delegate) {\n                var delegateResult = maybeInvokeDelegate(delegate, context);\n\n                if (delegateResult) {\n                  if (delegateResult === ContinueSentinel) continue;\n                  return delegateResult;\n                }\n              }\n\n              if (context.method === \"next\") {\n                // Setting context._sent for legacy support of Babel's\n                // function.sent implementation.\n                context.sent = context._sent = context.arg;\n              } else if (context.method === \"throw\") {\n                if (state === GenStateSuspendedStart) {\n                  state = GenStateCompleted;\n                  throw context.arg;\n                }\n\n                context.dispatchException(context.arg);\n              } else if (context.method === \"return\") {\n                context.abrupt(\"return\", context.arg);\n              }\n\n              state = GenStateExecuting;\n              var record = tryCatch(innerFn, self, context);\n\n              if (record.type === \"normal\") {\n                // If an exception is thrown from innerFn, we leave state ===\n                // GenStateExecuting and loop back for another invocation.\n                state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n                if (record.arg === ContinueSentinel) {\n                  continue;\n                }\n\n                return {\n                  value: record.arg,\n                  done: context.done\n                };\n              } else if (record.type === \"throw\") {\n                state = GenStateCompleted; // Dispatch the exception by looping back around to the\n                // context.dispatchException(context.arg) call above.\n\n                context.method = \"throw\";\n                context.arg = record.arg;\n              }\n            }\n          };\n        } // Call delegate.iterator[context.method](context.arg) and handle the\n        // result, either by returning a { value, done } result from the\n        // delegate iterator, or by modifying context.method and context.arg,\n        // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n        function maybeInvokeDelegate(delegate, context) {\n          var method = delegate.iterator[context.method];\n\n          if (method === undefined) {\n            // A .throw or .return when the delegate iterator has no .throw\n            // method always terminates the yield* loop.\n            context.delegate = null;\n\n            if (context.method === \"throw\") {\n              // Note: [\"return\"] must be used for ES3 parsing compatibility.\n              if (delegate.iterator[\"return\"]) {\n                // If the delegate iterator has a return method, give it a\n                // chance to clean up.\n                context.method = \"return\";\n                context.arg = undefined;\n                maybeInvokeDelegate(delegate, context);\n\n                if (context.method === \"throw\") {\n                  // If maybeInvokeDelegate(context) changed context.method from\n                  // \"return\" to \"throw\", let that override the TypeError below.\n                  return ContinueSentinel;\n                }\n              }\n\n              context.method = \"throw\";\n              context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n            }\n\n            return ContinueSentinel;\n          }\n\n          var record = tryCatch(method, delegate.iterator, context.arg);\n\n          if (record.type === \"throw\") {\n            context.method = \"throw\";\n            context.arg = record.arg;\n            context.delegate = null;\n            return ContinueSentinel;\n          }\n\n          var info = record.arg;\n\n          if (!info) {\n            context.method = \"throw\";\n            context.arg = new TypeError(\"iterator result is not an object\");\n            context.delegate = null;\n            return ContinueSentinel;\n          }\n\n          if (info.done) {\n            // Assign the result of the finished delegate to the temporary\n            // variable specified by delegate.resultName (see delegateYield).\n            context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n            context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n            // exception, let the outer generator proceed normally. If\n            // context.method was \"next\", forget context.arg since it has been\n            // \"consumed\" by the delegate iterator. If context.method was\n            // \"return\", allow the original .return call to continue in the\n            // outer generator.\n\n            if (context.method !== \"return\") {\n              context.method = \"next\";\n              context.arg = undefined;\n            }\n          } else {\n            // Re-yield the result returned by the delegate method.\n            return info;\n          } // The delegate iterator is finished, so forget it and continue with\n          // the outer generator.\n\n\n          context.delegate = null;\n          return ContinueSentinel;\n        } // Define Generator.prototype.{next,throw,return} in terms of the\n        // unified ._invoke helper method.\n\n\n        defineIteratorMethods(Gp);\n        Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n        // @@iterator function is called on it. Some browsers' implementations of the\n        // iterator prototype chain incorrectly implement this, causing the Generator\n        // object to not be returned from this call. This ensures that doesn't happen.\n        // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n        Gp[iteratorSymbol] = function () {\n          return this;\n        };\n\n        Gp.toString = function () {\n          return \"[object Generator]\";\n        };\n\n        function pushTryEntry(locs) {\n          var entry = {\n            tryLoc: locs[0]\n          };\n\n          if (1 in locs) {\n            entry.catchLoc = locs[1];\n          }\n\n          if (2 in locs) {\n            entry.finallyLoc = locs[2];\n            entry.afterLoc = locs[3];\n          }\n\n          this.tryEntries.push(entry);\n        }\n\n        function resetTryEntry(entry) {\n          var record = entry.completion || {};\n          record.type = \"normal\";\n          delete record.arg;\n          entry.completion = record;\n        }\n\n        function Context(tryLocsList) {\n          // The root entry object (effectively a try statement without a catch\n          // or a finally block) gives us a place to store values thrown from\n          // locations where there is no enclosing try statement.\n          this.tryEntries = [{\n            tryLoc: \"root\"\n          }];\n          tryLocsList.forEach(pushTryEntry, this);\n          this.reset(true);\n        }\n\n        exports.keys = function (object) {\n          var keys = [];\n\n          for (var key in object) {\n            keys.push(key);\n          }\n\n          keys.reverse(); // Rather than returning an object with a next method, we keep\n          // things simple and return the next function itself.\n\n          return function next() {\n            while (keys.length) {\n              var key = keys.pop();\n\n              if (key in object) {\n                next.value = key;\n                next.done = false;\n                return next;\n              }\n            } // To avoid creating an additional object, we just hang the .value\n            // and .done properties off the next function object itself. This\n            // also ensures that the minifier will not anonymize the function.\n\n\n            next.done = true;\n            return next;\n          };\n        };\n\n        function values(iterable) {\n          if (iterable) {\n            var iteratorMethod = iterable[iteratorSymbol];\n\n            if (iteratorMethod) {\n              return iteratorMethod.call(iterable);\n            }\n\n            if (typeof iterable.next === \"function\") {\n              return iterable;\n            }\n\n            if (!isNaN(iterable.length)) {\n              var i = -1,\n                  next = function next() {\n                while (++i < iterable.length) {\n                  if (hasOwn.call(iterable, i)) {\n                    next.value = iterable[i];\n                    next.done = false;\n                    return next;\n                  }\n                }\n\n                next.value = undefined;\n                next.done = true;\n                return next;\n              };\n\n              return next.next = next;\n            }\n          } // Return an iterator with no values.\n\n\n          return {\n            next: doneResult\n          };\n        }\n\n        exports.values = values;\n\n        function doneResult() {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n\n        Context.prototype = {\n          constructor: Context,\n          reset: function reset(skipTempReset) {\n            this.prev = 0;\n            this.next = 0; // Resetting context._sent for legacy support of Babel's\n            // function.sent implementation.\n\n            this.sent = this._sent = undefined;\n            this.done = false;\n            this.delegate = null;\n            this.method = \"next\";\n            this.arg = undefined;\n            this.tryEntries.forEach(resetTryEntry);\n\n            if (!skipTempReset) {\n              for (var name in this) {\n                // Not sure about the optimal order of these conditions:\n                if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n                  this[name] = undefined;\n                }\n              }\n            }\n          },\n          stop: function stop() {\n            this.done = true;\n            var rootEntry = this.tryEntries[0];\n            var rootRecord = rootEntry.completion;\n\n            if (rootRecord.type === \"throw\") {\n              throw rootRecord.arg;\n            }\n\n            return this.rval;\n          },\n          dispatchException: function dispatchException(exception) {\n            if (this.done) {\n              throw exception;\n            }\n\n            var context = this;\n\n            function handle(loc, caught) {\n              record.type = \"throw\";\n              record.arg = exception;\n              context.next = loc;\n\n              if (caught) {\n                // If the dispatched exception was caught by a catch block,\n                // then let that catch block handle the exception normally.\n                context.method = \"next\";\n                context.arg = undefined;\n              }\n\n              return !!caught;\n            }\n\n            for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n              var entry = this.tryEntries[i];\n              var record = entry.completion;\n\n              if (entry.tryLoc === \"root\") {\n                // Exception thrown outside of any try block that could handle\n                // it, so set the completion value of the entire function to\n                // throw the exception.\n                return handle(\"end\");\n              }\n\n              if (entry.tryLoc <= this.prev) {\n                var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n                if (hasCatch && hasFinally) {\n                  if (this.prev < entry.catchLoc) {\n                    return handle(entry.catchLoc, true);\n                  } else if (this.prev < entry.finallyLoc) {\n                    return handle(entry.finallyLoc);\n                  }\n                } else if (hasCatch) {\n                  if (this.prev < entry.catchLoc) {\n                    return handle(entry.catchLoc, true);\n                  }\n                } else if (hasFinally) {\n                  if (this.prev < entry.finallyLoc) {\n                    return handle(entry.finallyLoc);\n                  }\n                } else {\n                  throw new Error(\"try statement without catch or finally\");\n                }\n              }\n            }\n          },\n          abrupt: function abrupt(type, arg) {\n            for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n              var entry = this.tryEntries[i];\n\n              if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                var finallyEntry = entry;\n                break;\n              }\n            }\n\n            if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n              // Ignore the finally entry if control is not jumping to a\n              // location outside the try/catch block.\n              finallyEntry = null;\n            }\n\n            var record = finallyEntry ? finallyEntry.completion : {};\n            record.type = type;\n            record.arg = arg;\n\n            if (finallyEntry) {\n              this.method = \"next\";\n              this.next = finallyEntry.finallyLoc;\n              return ContinueSentinel;\n            }\n\n            return this.complete(record);\n          },\n          complete: function complete(record, afterLoc) {\n            if (record.type === \"throw\") {\n              throw record.arg;\n            }\n\n            if (record.type === \"break\" || record.type === \"continue\") {\n              this.next = record.arg;\n            } else if (record.type === \"return\") {\n              this.rval = this.arg = record.arg;\n              this.method = \"return\";\n              this.next = \"end\";\n            } else if (record.type === \"normal\" && afterLoc) {\n              this.next = afterLoc;\n            }\n\n            return ContinueSentinel;\n          },\n          finish: function finish(finallyLoc) {\n            for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n              var entry = this.tryEntries[i];\n\n              if (entry.finallyLoc === finallyLoc) {\n                this.complete(entry.completion, entry.afterLoc);\n                resetTryEntry(entry);\n                return ContinueSentinel;\n              }\n            }\n          },\n          \"catch\": function _catch(tryLoc) {\n            for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n              var entry = this.tryEntries[i];\n\n              if (entry.tryLoc === tryLoc) {\n                var record = entry.completion;\n\n                if (record.type === \"throw\") {\n                  var thrown = record.arg;\n                  resetTryEntry(entry);\n                }\n\n                return thrown;\n              }\n            } // The context.catch method must only be called with a location\n            // argument that corresponds to a known catch block.\n\n\n            throw new Error(\"illegal catch attempt\");\n          },\n          delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n            this.delegate = {\n              iterator: values(iterable),\n              resultName: resultName,\n              nextLoc: nextLoc\n            };\n\n            if (this.method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              this.arg = undefined;\n            }\n\n            return ContinueSentinel;\n          }\n        }; // Regardless of whether this script is executing as a CommonJS module\n        // or not, return the runtime object so that we can declare the variable\n        // regeneratorRuntime in the outer scope, which allows this module to be\n        // injected easily by `bin/regenerator --include-runtime script.js`.\n\n        return exports;\n      }( // If this script is executing as a CommonJS module, use module.exports\n      // as the regeneratorRuntime namespace. Otherwise create a new empty\n      // object. Either way, the resulting object will be used to initialize\n      // the regeneratorRuntime variable at the top of this file.\n      true ? module.exports : undefined);\n\n      try {\n        regeneratorRuntime = runtime;\n      } catch (accidentalStrictMode) {\n        // This module should not be running in strict mode, so the above\n        // assignment should always work unless something is misconfigured. Just\n        // in case runtime.js accidentally runs in strict mode, we can escape\n        // strict mode using a global Function call. This could conceivably fail\n        // if a Content Security Policy forbids using Function, but in that case\n        // the proper solution is to fix the accidental strict mode problem. If\n        // you've misconfigured your bundler to force strict mode and applied a\n        // CSP to forbid Function, and you're not willing to fix either of those\n        // problems, please detail your unique predicament in a GitHub issue.\n        Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n      }\n      /***/\n\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports) {\n      /* (ignored) */\n\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports) {\n      // Unique ID creation requires a high quality random # generator.  In the\n      // browser this is a little complicated due to unknown quality of Math.random()\n      // and inconsistent support for the `crypto` API.  We do the best we can via\n      // feature-detection\n      // getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n      // implementation. Also, find the complete implementation of crypto on IE11.\n      var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n      if (getRandomValues) {\n        // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n        var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n        module.exports = function whatwgRNG() {\n          getRandomValues(rnds8);\n          return rnds8;\n        };\n      } else {\n        // Math.random()-based (RNG)\n        //\n        // If all else fails, use Math.random().  It's fast, but is of unspecified\n        // quality.\n        var rnds = new Array(16);\n\n        module.exports = function mathRNG() {\n          for (var i = 0, r; i < 16; i++) {\n            if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n            rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n          }\n\n          return rnds;\n        };\n      }\n      /***/\n\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Convert array of 16 byte values to UUID string format of the form:\n       * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n       */\n      var byteToHex = [];\n\n      for (var i = 0; i < 256; ++i) {\n        byteToHex[i] = (i + 0x100).toString(16).substr(1);\n      }\n\n      function bytesToUuid(buf, offset) {\n        var i = offset || 0;\n        var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n        return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n      }\n\n      module.exports = bytesToUuid;\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n\n      __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\n\n\n      var helpers_typeof = __webpack_require__(5);\n\n      var typeof_default =\n      /*#__PURE__*/\n      __webpack_require__.n(helpers_typeof); // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js\n\n\n      var slicedToArray = __webpack_require__(6);\n\n      var slicedToArray_default =\n      /*#__PURE__*/\n      __webpack_require__.n(slicedToArray); // EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\n\n\n      var regenerator = __webpack_require__(0);\n\n      var regenerator_default =\n      /*#__PURE__*/\n      __webpack_require__.n(regenerator); // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n\n\n      var asyncToGenerator = __webpack_require__(2);\n\n      var asyncToGenerator_default =\n      /*#__PURE__*/\n      __webpack_require__.n(asyncToGenerator); // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js\n\n\n      var classCallCheck = __webpack_require__(3);\n\n      var classCallCheck_default =\n      /*#__PURE__*/\n      __webpack_require__.n(classCallCheck); // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js\n\n\n      var createClass = __webpack_require__(4);\n\n      var createClass_default =\n      /*#__PURE__*/\n      __webpack_require__.n(createClass); // EXTERNAL MODULE: ./src/worker.js\n\n\n      var worker = __webpack_require__(7);\n\n      var worker_default =\n      /*#__PURE__*/\n      __webpack_require__.n(worker); // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/util.js\n\n      /**\n       * returns true if the given object is a promise\n       */\n\n\n      function isPromise(obj) {\n        if (obj && typeof obj.then === 'function') {\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      function sleep(time) {\n        if (!time) time = 0;\n        return new Promise(function (res) {\n          return setTimeout(res, time);\n        });\n      }\n\n      function randomInt(min, max) {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n      }\n      /**\n       * https://stackoverflow.com/a/1349426/3443137\n       */\n\n\n      function randomToken(length) {\n        if (!length) length = 5;\n        var text = '';\n        var possible = 'abcdefghijklmnopqrstuvwxzy0123456789';\n\n        for (var i = 0; i < length; i++) {\n          text += possible.charAt(Math.floor(Math.random() * possible.length));\n        }\n\n        return text;\n      }\n\n      var lastMs = 0;\n      var additional = 0;\n      /**\n       * returns the current time in micro-seconds,\n       * WARNING: This is a pseudo-function\n       * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n       * This is enough in browsers, and this function will not be used in nodejs.\n       * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n       */\n\n      function microSeconds() {\n        var ms = new Date().getTime();\n\n        if (ms === lastMs) {\n          additional++;\n          return ms * 1000 + additional;\n        } else {\n          lastMs = ms;\n          additional = 0;\n          return ms * 1000;\n        }\n      } // EXTERNAL MODULE: ./node_modules/detect-node/browser.js\n\n\n      var browser = __webpack_require__(1);\n\n      var browser_default =\n      /*#__PURE__*/\n      __webpack_require__.n(browser); // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/methods/native.js\n\n\n      var native_microSeconds = microSeconds;\n      var type = 'native';\n\n      function create(channelName) {\n        var state = {\n          messagesCallback: null,\n          bc: new BroadcastChannel(channelName),\n          subFns: [] // subscriberFunctions\n\n        };\n\n        state.bc.onmessage = function (msg) {\n          if (state.messagesCallback) {\n            state.messagesCallback(msg.data);\n          }\n        };\n\n        return state;\n      }\n\n      function native_close(channelState) {\n        channelState.bc.close();\n        channelState.subFns = [];\n      }\n\n      function postMessage(channelState, messageJson) {\n        channelState.bc.postMessage(messageJson, false);\n      }\n\n      function onMessage(channelState, fn, time) {\n        channelState.messagesCallbackTime = time;\n        channelState.messagesCallback = fn;\n      }\n\n      function canBeUsed() {\n        /**\n         * in the electron-renderer, isNode will be true even if we are in browser-context\n         * so we also check if window is undefined\n         */\n        if (browser_default.a && typeof window === 'undefined') return false;\n\n        if (typeof BroadcastChannel === 'function') {\n          if (BroadcastChannel._pubkey) {\n            throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n          }\n\n          return true;\n        } else return false;\n      }\n\n      function averageResponseTime() {\n        return 100;\n      }\n      /* harmony default export */\n\n\n      var methods_native = {\n        create: create,\n        close: native_close,\n        onMessage: onMessage,\n        postMessage: postMessage,\n        canBeUsed: canBeUsed,\n        type: type,\n        averageResponseTime: averageResponseTime,\n        microSeconds: native_microSeconds\n      }; // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/oblivious-set.js\n\n      /**\n       *\n       *\n       */\n\n      var ObliviousSet = function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.set = new Set();\n        this.timeMap = new Map();\n        this.has = this.set.has.bind(this.set);\n      };\n\n      ObliviousSet.prototype = {\n        add: function add(value) {\n          this.timeMap.set(value, oblivious_set_now());\n          this.set.add(value);\n\n          _removeTooOldValues(this);\n        },\n        clear: function clear() {\n          this.set.clear();\n          this.timeMap.clear();\n        }\n      };\n\n      function _removeTooOldValues(obliviousSet) {\n        var olderThen = oblivious_set_now() - obliviousSet.ttl;\n        var iterator = obliviousSet.set[Symbol.iterator]();\n\n        while (true) {\n          var value = iterator.next().value;\n          if (!value) return; // no more elements\n\n          var time = obliviousSet.timeMap.get(value);\n\n          if (time < olderThen) {\n            obliviousSet.timeMap[\"delete\"](value);\n            obliviousSet.set[\"delete\"](value);\n          } else {\n            // we reached a value that is not old enough\n            return;\n          }\n        }\n      }\n\n      function oblivious_set_now() {\n        return new Date().getTime();\n      }\n      /* harmony default export */\n\n\n      var oblivious_set = ObliviousSet; // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/options.js\n\n      function fillOptionsWithDefaults(options) {\n        if (!options) options = {};\n        options = JSON.parse(JSON.stringify(options)); // main\n\n        if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n        if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n        if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n        if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; // localstorage\n\n        if (!options.localstorage) options.localstorage = {};\n        if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // node\n\n        if (!options.node) options.node = {};\n        if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n        if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n        return options;\n      } // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/methods/indexed-db.js\n\n      /**\n       * this method uses indexeddb to store the messages\n       * There is currently no observerAPI for idb\n       * @link https://github.com/w3c/IndexedDB/issues/51\n       */\n\n\n      var indexed_db_microSeconds = microSeconds;\n      var DB_PREFIX = 'pubkey.broadcast-channel-0-';\n      var OBJECT_STORE_ID = 'messages';\n      var indexed_db_type = 'idb';\n\n      function getIdb() {\n        if (typeof indexedDB !== 'undefined') return indexedDB;\n        if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n        if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n        if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n        return false;\n      }\n\n      function createDatabase(channelName) {\n        var IndexedDB = getIdb(); // create table\n\n        var dbName = DB_PREFIX + channelName;\n        var openRequest = IndexedDB.open(dbName, 1);\n\n        openRequest.onupgradeneeded = function (ev) {\n          var db = ev.target.result;\n          db.createObjectStore(OBJECT_STORE_ID, {\n            keyPath: 'id',\n            autoIncrement: true\n          });\n        };\n\n        var dbPromise = new Promise(function (res, rej) {\n          openRequest.onerror = function (ev) {\n            return rej(ev);\n          };\n\n          openRequest.onsuccess = function () {\n            res(openRequest.result);\n          };\n        });\n        return dbPromise;\n      }\n      /**\n       * writes the new message to the database\n       * so other readers can find it\n       */\n\n\n      function writeMessage(db, readerUuid, messageJson) {\n        var time = new Date().getTime();\n        var writeObject = {\n          uuid: readerUuid,\n          time: time,\n          data: messageJson\n        };\n        var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n        return new Promise(function (res, rej) {\n          transaction.oncomplete = function () {\n            return res();\n          };\n\n          transaction.onerror = function (ev) {\n            return rej(ev);\n          };\n\n          var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n          objectStore.add(writeObject);\n        });\n      }\n\n      function getAllMessages(db) {\n        var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n        var ret = [];\n        return new Promise(function (res) {\n          objectStore.openCursor().onsuccess = function (ev) {\n            var cursor = ev.target.result;\n\n            if (cursor) {\n              ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n              cursor[\"continue\"]();\n            } else {\n              res(ret);\n            }\n          };\n        });\n      }\n\n      function getMessagesHigherThen(db, lastCursorId) {\n        var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n        var ret = [];\n        var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n        return new Promise(function (res) {\n          objectStore.openCursor(keyRangeValue).onsuccess = function (ev) {\n            var cursor = ev.target.result;\n\n            if (cursor) {\n              ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n              cursor[\"continue\"]();\n            } else {\n              res(ret);\n            }\n          };\n        });\n      }\n\n      function removeMessageById(db, id) {\n        var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n        return new Promise(function (res) {\n          request.onsuccess = function () {\n            return res();\n          };\n        });\n      }\n\n      function getOldMessages(db, ttl) {\n        var olderThen = new Date().getTime() - ttl;\n        var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n        var ret = [];\n        return new Promise(function (res) {\n          objectStore.openCursor().onsuccess = function (ev) {\n            var cursor = ev.target.result;\n\n            if (cursor) {\n              var msgObk = cursor.value;\n\n              if (msgObk.time < olderThen) {\n                ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n                cursor[\"continue\"]();\n              } else {\n                // no more old messages,\n                res(ret);\n                return;\n              }\n            } else {\n              res(ret);\n            }\n          };\n        });\n      }\n\n      function cleanOldMessages(db, ttl) {\n        return getOldMessages(db, ttl).then(function (tooOld) {\n          return Promise.all(tooOld.map(function (msgObj) {\n            return removeMessageById(db, msgObj.id);\n          }));\n        });\n      }\n\n      function indexed_db_create(channelName, options) {\n        options = fillOptionsWithDefaults(options);\n        return createDatabase(channelName).then(function (db) {\n          var state = {\n            closed: false,\n            lastCursorId: 0,\n            channelName: channelName,\n            options: options,\n            uuid: randomToken(10),\n\n            /**\n             * emittedMessagesIds\n             * contains all messages that have been emitted before\n             * @type {ObliviousSet}\n             */\n            eMIs: new oblivious_set(options.idb.ttl * 2),\n            // ensures we do not read messages in parrallel\n            writeBlockPromise: Promise.resolve(),\n            messagesCallback: null,\n            readQueuePromises: [],\n            db: db\n          };\n          /**\n           * if service-workers are used,\n           * we have no 'storage'-event if they post a message,\n           * therefore we also have to set an interval\n           */\n\n          _readLoop(state);\n\n          return state;\n        });\n      }\n\n      function _readLoop(state) {\n        if (state.closed) return;\n        return readNewMessages(state).then(function () {\n          return sleep(state.options.idb.fallbackInterval);\n        }).then(function () {\n          return _readLoop(state);\n        });\n      }\n\n      function _filterMessage(msgObj, state) {\n        if (msgObj.uuid === state.uuid) return false; // send by own\n\n        if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n        if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n        return true;\n      }\n      /**\n       * reads all new messages from the database and emits them\n       */\n\n\n      function readNewMessages(state) {\n        // channel already closed\n        if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n        if (!state.messagesCallback) return Promise.resolve();\n        return getMessagesHigherThen(state.db, state.lastCursorId).then(function (newerMessages) {\n          var useMessages = newerMessages.map(function (msgObj) {\n            if (msgObj.id > state.lastCursorId) {\n              state.lastCursorId = msgObj.id;\n            }\n\n            return msgObj;\n          }).filter(function (msgObj) {\n            return _filterMessage(msgObj, state);\n          }).sort(function (msgObjA, msgObjB) {\n            return msgObjA.time - msgObjB.time;\n          }); // sort by time\n\n          useMessages.forEach(function (msgObj) {\n            if (state.messagesCallback) {\n              state.eMIs.add(msgObj.id);\n              state.messagesCallback(msgObj.data);\n            }\n          });\n          return Promise.resolve();\n        });\n      }\n\n      function indexed_db_close(channelState) {\n        channelState.closed = true;\n        channelState.db.close();\n      }\n\n      function indexed_db_postMessage(channelState, messageJson) {\n        channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n          return writeMessage(channelState.db, channelState.uuid, messageJson);\n        }).then(function () {\n          if (randomInt(0, 10) === 0) {\n            /* await (do not await) */\n            cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n          }\n        });\n        return channelState.writeBlockPromise;\n      }\n\n      function indexed_db_onMessage(channelState, fn, time) {\n        channelState.messagesCallbackTime = time;\n        channelState.messagesCallback = fn;\n        readNewMessages(channelState);\n      }\n\n      function indexed_db_canBeUsed() {\n        if (browser_default.a) return false;\n        var idb = getIdb();\n        if (!idb) return false;\n        return true;\n      }\n\n      function indexed_db_averageResponseTime(options) {\n        return options.idb.fallbackInterval * 2;\n      }\n      /* harmony default export */\n\n\n      var indexed_db = {\n        create: indexed_db_create,\n        close: indexed_db_close,\n        onMessage: indexed_db_onMessage,\n        postMessage: indexed_db_postMessage,\n        canBeUsed: indexed_db_canBeUsed,\n        type: indexed_db_type,\n        averageResponseTime: indexed_db_averageResponseTime,\n        microSeconds: indexed_db_microSeconds\n      }; // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/methods/localstorage.js\n\n      /**\n       * A localStorage-only method which uses localstorage and its 'storage'-event\n       * This does not work inside of webworkers because they have no access to locastorage\n       * This is basically implemented to support IE9 or your grandmothers toaster.\n       * @link https://caniuse.com/#feat=namevalue-storage\n       * @link https://caniuse.com/#feat=indexeddb\n       */\n\n      var localstorage_microSeconds = microSeconds;\n      var KEY_PREFIX = 'pubkey.broadcastChannel-';\n      var localstorage_type = 'localstorage';\n      /**\n       * copied from crosstab\n       * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n       */\n\n      function getLocalStorage() {\n        var localStorage;\n        if (typeof window === 'undefined') return null;\n\n        try {\n          localStorage = window.localStorage;\n          localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n        } catch (e) {// New versions of Firefox throw a Security exception\n          // if cookies are disabled. See\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n        }\n\n        return localStorage;\n      }\n\n      function storageKey(channelName) {\n        return KEY_PREFIX + channelName;\n      }\n      /**\n      * writes the new message to the storage\n      * and fires the storage-event so other readers can find it\n      */\n\n\n      function localstorage_postMessage(channelState, messageJson) {\n        return new Promise(function (res) {\n          sleep().then(function () {\n            var key = storageKey(channelState.channelName);\n            var writeObj = {\n              token: randomToken(10),\n              time: new Date().getTime(),\n              data: messageJson,\n              uuid: channelState.uuid\n            };\n            var value = JSON.stringify(writeObj);\n            localStorage.setItem(key, value);\n            /**\n             * StorageEvent does not fire the 'storage' event\n             * in the window that changes the state of the local storage.\n             * So we fire it manually\n             */\n\n            var ev = document.createEvent('Event');\n            ev.initEvent('storage', true, true);\n            ev.key = key;\n            ev.newValue = value;\n            window.dispatchEvent(ev);\n            res();\n          });\n        });\n      }\n\n      function addStorageEventListener(channelName, fn) {\n        var key = storageKey(channelName);\n\n        var listener = function listener(ev) {\n          if (ev.key === key) {\n            fn(JSON.parse(ev.newValue));\n          }\n        };\n\n        window.addEventListener('storage', listener);\n        return listener;\n      }\n\n      function removeStorageEventListener(listener) {\n        window.removeEventListener('storage', listener);\n      }\n\n      function localstorage_create(channelName, options) {\n        options = fillOptionsWithDefaults(options);\n\n        if (!localstorage_canBeUsed()) {\n          throw new Error('BroadcastChannel: localstorage cannot be used');\n        }\n\n        var uuid = randomToken(10);\n        /**\n         * eMIs\n         * contains all messages that have been emitted before\n         * @type {ObliviousSet}\n         */\n\n        var eMIs = new oblivious_set(options.localstorage.removeTimeout);\n        var state = {\n          channelName: channelName,\n          uuid: uuid,\n          eMIs: eMIs // emittedMessagesIds\n\n        };\n        state.listener = addStorageEventListener(channelName, function (msgObj) {\n          if (!state.messagesCallback) return; // no listener\n\n          if (msgObj.uuid === uuid) return; // own message\n\n          if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n          if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n          eMIs.add(msgObj.token);\n          state.messagesCallback(msgObj.data);\n        });\n        return state;\n      }\n\n      function localstorage_close(channelState) {\n        removeStorageEventListener(channelState.listener);\n      }\n\n      function localstorage_onMessage(channelState, fn, time) {\n        channelState.messagesCallbackTime = time;\n        channelState.messagesCallback = fn;\n      }\n\n      function localstorage_canBeUsed() {\n        if (browser_default.a) return false;\n        var ls = getLocalStorage();\n        if (!ls) return false;\n        return true;\n      }\n\n      function localstorage_averageResponseTime() {\n        return 120;\n      }\n      /* harmony default export */\n\n\n      var localstorage = {\n        create: localstorage_create,\n        close: localstorage_close,\n        onMessage: localstorage_onMessage,\n        postMessage: localstorage_postMessage,\n        canBeUsed: localstorage_canBeUsed,\n        type: localstorage_type,\n        averageResponseTime: localstorage_averageResponseTime,\n        microSeconds: localstorage_microSeconds\n      }; // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/method-chooser.js\n\n      var require; // order is important\n\n\n      var METHODS = [methods_native, // fastest\n      indexed_db, localstorage];\n      var REQUIRE_FUN = require;\n      /**\n       * The NodeMethod is loaded lazy\n       * so it will not get bundled in browser-builds\n       */\n\n      if (browser_default.a) {\n        /**\n         * we use the non-transpiled code for nodejs\n         * because it runs faster\n         */\n        var NodeMethod = __webpack_require__(14);\n        /**\n         * this will be false for webpackbuilds\n         * which will shim the node-method with an empty object {}\n         */\n\n\n        if (typeof NodeMethod.canBeUsed === 'function') {\n          METHODS.push(NodeMethod);\n        }\n      }\n\n      function chooseMethod(options) {\n        // directly chosen\n        if (options.type) {\n          var ret = METHODS.find(function (m) {\n            return m.type === options.type;\n          });\n          if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n        }\n\n        var chooseMethods = METHODS;\n\n        if (!options.webWorkerSupport && !browser_default.a) {\n          // prefer localstorage over idb when no webworker-support needed\n          chooseMethods = METHODS.filter(function (m) {\n            return m.type !== 'idb';\n          });\n        }\n\n        var useMethod = chooseMethods.find(function (method) {\n          return method.canBeUsed();\n        });\n        if (!useMethod) throw new Error('No useable methode found:' + JSON.stringify(METHODS.map(function (m) {\n          return m.type;\n        })));else return useMethod;\n      } // CONCATENATED MODULE: ./node_modules/broadcast-channel/dist/es/index.js\n\n\n      var es_BroadcastChannel = function BroadcastChannel(name, options) {\n        this.name = name;\n        this.options = fillOptionsWithDefaults(options);\n        this.method = chooseMethod(this.options); // isListening\n\n        this._iL = false;\n        /**\n         * _onMessageListener\n         * setting onmessage twice,\n         * will overwrite the first listener\n         */\n\n        this._onML = null;\n        /**\n         * _addEventListeners\n         */\n\n        this._addEL = {\n          message: [],\n          internal: []\n        };\n        /**\n         * _beforeClose\n         * array of promises that will be awaited\n         * before the channel is closed\n         */\n\n        this._befC = [];\n        /**\n         * _preparePromise\n         */\n\n        this._prepP = null;\n\n        _prepareChannel(this);\n      }; // STATICS\n\n      /**\n       * used to identify if someone overwrites\n       * window.BroadcastChannel with this\n       * See methods/native.js\n       */\n\n\n      es_BroadcastChannel._pubkey = true;\n      /**\n       * clears the tmp-folder if is node\n       * @return {Promise<boolean>} true if has run, false if not node\n       */\n\n      es_BroadcastChannel.clearNodeFolder = function (options) {\n        options = fillOptionsWithDefaults(options);\n        var method = chooseMethod(options);\n\n        if (method.type === 'node') {\n          return method.clearNodeFolder().then(function () {\n            return true;\n          });\n        } else {\n          return Promise.resolve(false);\n        }\n      }; // PROTOTYPE\n\n\n      es_BroadcastChannel.prototype = {\n        postMessage: function postMessage(msg) {\n          if (this.closed) {\n            throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n          }\n\n          return _post(this, 'message', msg);\n        },\n        postInternal: function postInternal(msg) {\n          return _post(this, 'internal', msg);\n        },\n\n        set onmessage(fn) {\n          var time = this.method.microSeconds();\n          var listenObj = {\n            time: time,\n            fn: fn\n          };\n\n          _removeListenerObject(this, 'message', this._onML);\n\n          if (fn && typeof fn === 'function') {\n            this._onML = listenObj;\n\n            _addListenerObject(this, 'message', listenObj);\n          } else {\n            this._onML = null;\n          }\n        },\n\n        addEventListener: function addEventListener(type, fn) {\n          var time = this.method.microSeconds();\n          var listenObj = {\n            time: time,\n            fn: fn\n          };\n\n          _addListenerObject(this, type, listenObj);\n        },\n        removeEventListener: function removeEventListener(type, fn) {\n          var obj = this._addEL[type].find(function (obj) {\n            return obj.fn === fn;\n          });\n\n          _removeListenerObject(this, type, obj);\n        },\n        close: function close() {\n          var _this = this;\n\n          if (this.closed) return;\n          this.closed = true;\n          var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n          this._onML = null;\n          this._addEL.message = [];\n          return awaitPrepare.then(function () {\n            return Promise.all(_this._befC.map(function (fn) {\n              return fn();\n            }));\n          }).then(function () {\n            return _this.method.close(_this._state);\n          });\n        },\n\n        get type() {\n          return this.method.type;\n        }\n\n      };\n\n      function _post(broadcastChannel, type, msg) {\n        var time = broadcastChannel.method.microSeconds();\n        var msgObj = {\n          time: time,\n          type: type,\n          data: msg\n        };\n        var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n        return awaitPrepare.then(function () {\n          return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n        });\n      }\n\n      function _prepareChannel(channel) {\n        var maybePromise = channel.method.create(channel.name, channel.options);\n\n        if (isPromise(maybePromise)) {\n          channel._prepP = maybePromise;\n          maybePromise.then(function (s) {\n            // used in tests to simulate slow runtime\n\n            /*if (channel.options.prepareDelay) {\n                 await new Promise(res => setTimeout(res, this.options.prepareDelay));\n            }*/\n            channel._state = s;\n          });\n        } else {\n          channel._state = maybePromise;\n        }\n      }\n\n      function _hasMessageListeners(channel) {\n        if (channel._addEL.message.length > 0) return true;\n        if (channel._addEL.internal.length > 0) return true;\n        return false;\n      }\n\n      function _addListenerObject(channel, type, obj) {\n        channel._addEL[type].push(obj);\n\n        _startListening(channel);\n      }\n\n      function _removeListenerObject(channel, type, obj) {\n        channel._addEL[type] = channel._addEL[type].filter(function (o) {\n          return o !== obj;\n        });\n\n        _stopListening(channel);\n      }\n\n      function _startListening(channel) {\n        if (!channel._iL && _hasMessageListeners(channel)) {\n          // someone is listening, start subscribing\n          var listenerFn = function listenerFn(msgObj) {\n            channel._addEL[msgObj.type].forEach(function (obj) {\n              if (msgObj.time >= obj.time) {\n                obj.fn(msgObj.data);\n              }\n            });\n          };\n\n          var time = channel.method.microSeconds();\n\n          if (channel._prepP) {\n            channel._prepP.then(function () {\n              channel._iL = true;\n              channel.method.onMessage(channel._state, listenerFn, time);\n            });\n          } else {\n            channel._iL = true;\n            channel.method.onMessage(channel._state, listenerFn, time);\n          }\n        }\n      }\n\n      function _stopListening(channel) {\n        if (channel._iL && !_hasMessageListeners(channel)) {\n          // noone is listening, stop subscribing\n          channel._iL = false;\n          var time = channel.method.microSeconds();\n          channel.method.onMessage(channel._state, null, time);\n        }\n      }\n      /* harmony default export */\n\n\n      var es = es_BroadcastChannel; // EXTERNAL MODULE: ./node_modules/uuid/v4.js\n\n      var v4 = __webpack_require__(8);\n\n      var v4_default =\n      /*#__PURE__*/\n      __webpack_require__.n(v4); // CONCATENATED MODULE: ./src/logger.js\n\n\n      var logger_Logger =\n      /*#__PURE__*/\n      function () {\n        function Logger() {\n          classCallCheck_default()(this, Logger);\n          this.setVerbosity('WARNING');\n        }\n\n        createClass_default()(Logger, [{\n          key: \"debug\",\n          value: function debug() {\n            if (this.checkVerbosity(4)) {\n              var _console;\n\n              (_console = console).log.apply(_console, arguments);\n            }\n          }\n        }, {\n          key: \"log\",\n          value: function log() {\n            if (this.checkVerbosity(4)) {\n              var _console2;\n\n              (_console2 = console).log.apply(_console2, arguments);\n            }\n          }\n        }, {\n          key: \"info\",\n          value: function info() {\n            if (this.checkVerbosity(3)) {\n              var _console3;\n\n              (_console3 = console).info.apply(_console3, arguments);\n            }\n          }\n        }, {\n          key: \"warn\",\n          value: function warn() {\n            if (this.checkVerbosity(2)) {\n              var _console4;\n\n              (_console4 = console).warn.apply(_console4, arguments);\n            }\n          }\n        }, {\n          key: \"error\",\n          value: function error() {\n            if (this.checkVerbosity(1)) {\n              var _console5;\n\n              (_console5 = console).error.apply(_console5, arguments);\n            }\n          }\n        }, {\n          key: \"setVerbosity\",\n          value: function setVerbosity(level) {\n            var default_level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';\n\n            if (level === undefined) {\n              level = default_level;\n            }\n\n            if (typeof level === 'string') {\n              level = {\n                ERROR: 1,\n                WARNING: 2,\n                INFO: 3,\n                LOG: 4,\n                DEBUG: 4\n              }[level.toUpperCase()] || 2;\n            }\n\n            this.level = level;\n          }\n        }, {\n          key: \"checkVerbosity\",\n          value: function checkVerbosity(level) {\n            return this.level >= level;\n          }\n        }]);\n        return Logger;\n      }();\n\n      var log = new logger_Logger();\n      /* harmony default export */\n\n      var logger = log; // CONCATENATED MODULE: ./src/index.js\n      //import localforage from 'localforage';\n\n      var src_sleep = function sleep(ms) {\n        return new Promise(function (res) {\n          return setTimeout(res, ms);\n        });\n      };\n      /**\n       * TDLib in a browser\n       *\n       * TDLib can be compiled to WebAssembly or asm.js using Emscripten compiler and used in a browser from JavaScript.\n       * This is a convenient wrapper for TDLib in a browser which controls TDLib instance creation, handles interaction\n       * with TDLib and manages a filesystem for persistent TDLib data.\n       * TDLib instance is created in a Web Worker to run it in a separate thread.\n       * TdClient just sends queries to the Web Worker and receives updates and results from it.\n       * <br>\n       * <br>\n       * Differences from the TDLib JSON API:<br>\n       * 1. Added the update <code>updateFatalError error:string = Update;</code> which is sent whenever TDLib encounters a fatal error.<br>\n       * 2. Added the method <code>setJsLogVerbosityLevel new_verbosity_level:string = Ok;</code>, which allows to change the verbosity level of tdweb logging.<br>\n       * 3. Added the possibility to use blobs as input files via the constructor <code>inputFileBlob data:<JavaScript blob> = InputFile;</code>.<br>\n       * 4. The class <code>filePart</code> contains data as a JavaScript blob instead of a base64-encoded string.<br>\n       * 5. The methods <code>getStorageStatistics</code>, <code>getStorageStatisticsFast</code>, <code>optimizeStorage</code>, <code>addProxy</code> and <code>getFileDownloadedPrefixSize</code> are not supported.<br>\n       * <br>\n       */\n\n\n      var src_TdClient =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @callback TdClient~updateCallback\n         * @param {Object} update The update.\n         */\n\n        /**\n         * Create TdClient.\n         * @param {Object} options - Options for TDLib instance creation.\n         * @param {TdClient~updateCallback} options.onUpdate - Callback for all incoming updates.\n         * @param {string} [options.instanceName=tdlib] - Name of the TDLib instance. Currently only one instance of TdClient with a given name is allowed. All but one instances with the same name will be automatically closed. Usually, the newest non-background instance is kept alive. Files will be stored in an IndexedDb table with the same name.\n         * @param {boolean} [options.isBackground=false] - Pass true, if the instance is opened from the background.\n         * @param {string} [options.jsLogVerbosityLevel=info] - The initial verbosity level of the JavaScript part of the code (one of 'error', 'warning', 'info', 'log', 'debug').\n         * @param {number} [options.logVerbosityLevel=2] - The initial verbosity level for the TDLib internal logging (0-1023).\n         * @param {boolean} [options.useDatabase=true] - Pass false to use TDLib without database and secret chats. It will significantly improve loading time, but some functionality will be unavailable.\n         * @param {boolean} [options.readOnly=false] - For debug only. Pass true to open TDLib database in read-only mode\n         * @param {string} [options.mode=auto] - For debug only. The type of the TDLib build to use. 'asmjs' for asm.js and 'wasm' for WebAssembly. If mode == 'auto' WebAbassembly will be used if supported by browser, asm.js otherwise.\n         */\n        function TdClient(options) {\n          var _this = this;\n\n          classCallCheck_default()(this, TdClient);\n          logger.setVerbosity(options.jsLogVerbosityLevel);\n          this.worker = new worker_default.a();\n\n          this.worker.onmessage = function (e) {\n            _this.onResponse(e.data);\n          };\n\n          this.query_id = 0;\n          this.query_callbacks = new Map();\n\n          if ('onUpdate' in options) {\n            this.onUpdate = options.onUpdate;\n            delete options.onUpdate;\n          }\n\n          options.instanceName = options.instanceName || 'tdlib';\n          this.fileManager = new src_FileManager(options.instanceName, this);\n          this.worker.postMessage({\n            '@type': 'init',\n            options: options\n          });\n          this.closeOtherClients(options);\n        }\n        /**\n         * Send a query to TDLib.\n         *\n         * If the query contains the field '@extra', the same field will be added into the result.\n         *\n         * @param {Object} query - The query for TDLib. See the [td_api.tl]{@link https://github.com/tdlib/td/blob/master/td/generate/scheme/td_api.tl} scheme or\n         *                         the automatically generated [HTML documentation]{@link https://core.telegram.org/tdlib/docs/td__api_8h.html}\n         *                         for a list of all available TDLib [methods]{@link https://core.telegram.org/tdlib/docs/classtd_1_1td__api_1_1_function.html} and\n         *                         [classes]{@link https://core.telegram.org/tdlib/docs/classtd_1_1td__api_1_1_object.html}.\n         * @returns {Promise} Promise object represents the result of the query.\n         */\n\n\n        createClass_default()(TdClient, [{\n          key: \"send\",\n          value: function send(query) {\n            return this.doSend(query, true);\n          }\n          /** @private */\n\n        }, {\n          key: \"sendInternal\",\n          value: function sendInternal(query) {\n            return this.doSend(query, false);\n          }\n          /** @private */\n\n        }, {\n          key: \"doSend\",\n          value: function doSend(query, isExternal) {\n            var _this2 = this;\n\n            this.query_id++;\n\n            if (query['@extra']) {\n              query['@extra'] = {\n                '@old_extra': JSON.parse(JSON.stringify(query['@extra'])),\n                query_id: this.query_id\n              };\n            } else {\n              query['@extra'] = {\n                query_id: this.query_id\n              };\n            }\n\n            if (query['@type'] === 'setJsLogVerbosityLevel') {\n              logger.setVerbosity(query.new_verbosity_level);\n            }\n\n            logger.debug('send to worker: ', query);\n            var res = new Promise(function (resolve, reject) {\n              _this2.query_callbacks.set(_this2.query_id, [resolve, reject]);\n            });\n\n            if (isExternal) {\n              this.externalPostMessage(query);\n            } else {\n              this.worker.postMessage(query);\n            }\n\n            return res;\n          }\n          /** @private */\n\n        }, {\n          key: \"externalPostMessage\",\n          value: function externalPostMessage(query) {\n            var unsupportedMethods = ['getStorageStatistics', 'getStorageStatisticsFast', 'optimizeStorage', 'addProxy', 'init', 'start'];\n\n            if (unsupportedMethods.includes(query['@type'])) {\n              this.onResponse({\n                '@type': 'error',\n                '@extra': query['@extra'],\n                code: 400,\n                message: \"Method '\" + query['@type'] + \"' is not supported\"\n              });\n              return;\n            }\n\n            if (query['@type'] === 'readFile' || query['@type'] === 'readFilePart') {\n              this.readFile(query);\n              return;\n            }\n\n            if (query['@type'] === 'deleteFile') {\n              this.deleteFile(query);\n              return;\n            }\n\n            this.worker.postMessage(query);\n          }\n          /** @private */\n\n        }, {\n          key: \"readFile\",\n          value: function () {\n            var _readFile = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee(query) {\n              var response;\n              return regenerator_default.a.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.next = 2;\n                      return this.fileManager.readFile(query);\n\n                    case 2:\n                      response = _context.sent;\n                      this.onResponse(response);\n\n                    case 4:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, this);\n            }));\n\n            function readFile(_x) {\n              return _readFile.apply(this, arguments);\n            }\n\n            return readFile;\n          }()\n          /** @private */\n\n        }, {\n          key: \"deleteFile\",\n          value: function () {\n            var _deleteFile = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee2(query) {\n              var response;\n              return regenerator_default.a.wrap(function _callee2$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      response = this.fileManager.deleteFile(query);\n                      _context2.prev = 1;\n\n                      if (!response.idb_key) {\n                        _context2.next = 6;\n                        break;\n                      }\n\n                      _context2.next = 5;\n                      return this.sendInternal({\n                        '@type': 'deleteIdbKey',\n                        idb_key: response.idb_key\n                      });\n\n                    case 5:\n                      delete response.idb_key;\n\n                    case 6:\n                      _context2.next = 8;\n                      return this.sendInternal({\n                        '@type': 'deleteFile',\n                        file_id: query.file_id\n                      });\n\n                    case 8:\n                      _context2.next = 12;\n                      break;\n\n                    case 10:\n                      _context2.prev = 10;\n                      _context2.t0 = _context2[\"catch\"](1);\n\n                    case 12:\n                      this.onResponse(response);\n\n                    case 13:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee2, this, [[1, 10]]);\n            }));\n\n            function deleteFile(_x2) {\n              return _deleteFile.apply(this, arguments);\n            }\n\n            return deleteFile;\n          }()\n          /** @private */\n\n        }, {\n          key: \"onResponse\",\n          value: function onResponse(response) {\n            logger.debug('receive from worker: ', JSON.parse(JSON.stringify(response, function (key, value) {\n              if (key === 'arr') {\n                return undefined;\n              }\n\n              return value;\n            }))); // for FileManager\n\n            response = this.prepareResponse(response);\n\n            if ('@extra' in response) {\n              var query_id = response['@extra'].query_id;\n\n              var _this$query_callbacks = this.query_callbacks.get(query_id),\n                  _this$query_callbacks2 = slicedToArray_default()(_this$query_callbacks, 2),\n                  resolve = _this$query_callbacks2[0],\n                  reject = _this$query_callbacks2[1];\n\n              this.query_callbacks[\"delete\"](query_id);\n\n              if ('@old_extra' in response['@extra']) {\n                response['@extra'] = response['@extra']['@old_extra'];\n              }\n\n              if (resolve) {\n                if (response['@type'] === 'error') {\n                  reject(response);\n                } else {\n                  resolve(response);\n                }\n              }\n            } else {\n              if (response['@type'] === 'inited') {\n                this.onInited();\n                return;\n              }\n\n              if (response['@type'] === 'fsInited') {\n                this.onFsInited();\n                return;\n              }\n\n              if (response['@type'] === 'updateAuthorizationState' && response.authorization_state['@type'] === 'authorizationStateClosed') {\n                this.onClosed();\n              }\n\n              this.onUpdate(response);\n            }\n          }\n          /** @private */\n\n        }, {\n          key: \"prepareFile\",\n          value: function prepareFile(file) {\n            return this.fileManager.registerFile(file);\n          }\n          /** @private */\n\n        }, {\n          key: \"prepareResponse\",\n          value: function prepareResponse(response) {\n            var _this3 = this;\n\n            if (response['@type'] === 'file') {\n              if (false) {}\n\n              return this.prepareFile(response);\n            }\n\n            for (var key in response) {\n              var field = response[key];\n\n              if (field && typeof_default()(field) === 'object') {\n                response[key] = this.prepareResponse(field);\n              }\n            }\n\n            return response;\n          }\n          /** @private */\n\n        }, {\n          key: \"onBroadcastMessage\",\n          value: function onBroadcastMessage(e) {\n            //const message = e.data;\n            var message = e;\n\n            if (message.uid === this.uid) {\n              logger.info('ignore self broadcast message: ', message);\n              return;\n            }\n\n            logger.info('got broadcast message: ', message);\n\n            if (message.isBackground && !this.isBackground) {// continue\n            } else if (!message.isBackground && this.isBackground || message.timestamp > this.timestamp) {\n              this.close();\n              return;\n            }\n\n            if (message.state === 'closed') {\n              this.waitSet[\"delete\"](message.uid);\n\n              if (this.waitSet.size === 0) {\n                logger.info('onWaitSetEmpty');\n                this.onWaitSetEmpty();\n\n                this.onWaitSetEmpty = function () {};\n              }\n            } else {\n              this.waitSet.add(message.uid);\n\n              if (message.state !== 'closing') {\n                this.postState();\n              }\n            }\n          }\n          /** @private */\n\n        }, {\n          key: \"postState\",\n          value: function postState() {\n            var state = {\n              uid: this.uid,\n              state: this.state,\n              timestamp: this.timestamp,\n              isBackground: this.isBackground\n            };\n            logger.info('Post state: ', state);\n            this.channel.postMessage(state);\n          }\n          /** @private */\n\n        }, {\n          key: \"onWaitSetEmpty\",\n          value: function onWaitSetEmpty() {} // nop\n\n          /** @private */\n\n        }, {\n          key: \"onFsInited\",\n          value: function onFsInited() {\n            this.fileManager.init();\n          }\n          /** @private */\n\n        }, {\n          key: \"onInited\",\n          value: function onInited() {\n            this.isInited = true;\n            this.doSendStart();\n          }\n          /** @private */\n\n        }, {\n          key: \"sendStart\",\n          value: function sendStart() {\n            this.wantSendStart = true;\n            this.doSendStart();\n          }\n          /** @private */\n\n        }, {\n          key: \"doSendStart\",\n          value: function doSendStart() {\n            if (!this.isInited || !this.wantSendStart || this.state !== 'start') {\n              return;\n            }\n\n            this.wantSendStart = false;\n            this.state = 'active';\n            var query = {\n              '@type': 'start'\n            };\n            logger.info('send to worker: ', query);\n            this.worker.postMessage(query);\n          }\n          /** @private */\n\n        }, {\n          key: \"onClosed\",\n          value: function onClosed() {\n            this.isClosing = true;\n            this.worker.terminate();\n            logger.info('worker is terminated');\n            this.state = 'closed';\n            this.postState();\n          }\n          /** @private */\n\n        }, {\n          key: \"close\",\n          value: function close() {\n            if (this.isClosing) {\n              return;\n            }\n\n            this.isClosing = true;\n            logger.info('close state: ', this.state);\n\n            if (this.state === 'start') {\n              this.onClosed();\n              this.onUpdate({\n                '@type': 'updateAuthorizationState',\n                authorization_state: {\n                  '@type': 'authorizationStateClosed'\n                }\n              });\n              return;\n            }\n\n            var query = {\n              '@type': 'close'\n            };\n            logger.info('send to worker: ', query);\n            this.worker.postMessage(query);\n            this.state = 'closing';\n            this.postState();\n          }\n          /** @private */\n\n        }, {\n          key: \"closeOtherClients\",\n          value: function () {\n            var _closeOtherClients = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee4(options) {\n              var _this4 = this;\n\n              return regenerator_default.a.wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      this.uid = v4_default()();\n                      this.state = 'start';\n                      this.isBackground = !!options.isBackground;\n                      this.timestamp = Date.now();\n                      this.waitSet = new Set();\n                      logger.info('close other clients');\n                      this.channel = new es(options.instanceName, {\n                        webWorkerSupport: false\n                      });\n                      this.postState();\n\n                      this.channel.onmessage = function (message) {\n                        _this4.onBroadcastMessage(message);\n                      };\n\n                      _context4.next = 11;\n                      return src_sleep(300);\n\n                    case 11:\n                      if (!(this.waitSet.size !== 0)) {\n                        _context4.next = 14;\n                        break;\n                      }\n\n                      _context4.next = 14;\n                      return new Promise(function (resolve) {\n                        _this4.onWaitSetEmpty = resolve;\n                      });\n\n                    case 14:\n                      this.sendStart();\n\n                    case 15:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4, this);\n            }));\n\n            function closeOtherClients(_x3) {\n              return _closeOtherClients.apply(this, arguments);\n            }\n\n            return closeOtherClients;\n          }()\n          /** @private */\n\n        }, {\n          key: \"onUpdate\",\n          value: function onUpdate(update) {\n            logger.info('ignore onUpdate'); //nop\n          }\n        }]);\n        return TdClient;\n      }();\n      /** @private */\n\n\n      var src_ListNode =\n      /*#__PURE__*/\n      function () {\n        function ListNode(value) {\n          classCallCheck_default()(this, ListNode);\n          this.value = value;\n          this.clear();\n        }\n\n        createClass_default()(ListNode, [{\n          key: \"erase\",\n          value: function erase() {\n            this.prev.connect(this.next);\n            this.clear();\n          }\n        }, {\n          key: \"clear\",\n          value: function clear() {\n            this.prev = this;\n            this.next = this;\n          }\n        }, {\n          key: \"connect\",\n          value: function connect(other) {\n            this.next = other;\n            other.prev = this;\n          }\n        }, {\n          key: \"onUsed\",\n          value: function onUsed(other) {\n            other.usedAt = Date.now();\n            other.erase();\n            other.connect(this.next);\n            logger.debug('LRU: used file_id: ', other.value);\n            this.connect(other);\n          }\n        }, {\n          key: \"getLru\",\n          value: function getLru() {\n            if (this === this.next) {\n              throw new Error('popLru from empty list');\n            }\n\n            return this.prev;\n          }\n        }]);\n        return ListNode;\n      }();\n      /** @private */\n\n\n      var src_FileManager =\n      /*#__PURE__*/\n      function () {\n        function FileManager(instanceName, client) {\n          classCallCheck_default()(this, FileManager);\n          this.instanceName = instanceName;\n          this.cache = new Map();\n          this.pending = [];\n          this.transaction_id = 0;\n          this.totalSize = 0;\n          this.lru = new src_ListNode(-1);\n          this.client = client;\n        }\n\n        createClass_default()(FileManager, [{\n          key: \"init\",\n          value: function init() {\n            var _this5 = this;\n\n            this.idb = new Promise(function (resolve, reject) {\n              var request = window.indexedDB.open(_this5.instanceName);\n\n              request.onsuccess = function () {\n                return resolve(request.result);\n              };\n\n              request.onerror = function () {\n                return reject(request.error);\n              };\n            }); //this.store = localforage.createInstance({\n            //name: instanceName\n            //});\n\n            this.isInited = true;\n          }\n        }, {\n          key: \"unload\",\n          value: function unload(info) {\n            if (info.arr) {\n              logger.debug('LRU: delete file_id: ', info.node.value, ' with arr.length: ', info.arr.length);\n              this.totalSize -= info.arr.length;\n              delete info.arr;\n            }\n\n            if (info.node) {\n              info.node.erase();\n              delete info.node;\n            }\n          }\n        }, {\n          key: \"registerFile\",\n          value: function registerFile(file) {\n            if (file.idb_key || file.arr) {\n              file.local.is_downloading_completed = true;\n            } else {\n              file.local.is_downloading_completed = false;\n            }\n\n            var info = {};\n            var cached_info = this.cache.get(file.id);\n\n            if (cached_info) {\n              info = cached_info;\n            } else {\n              this.cache.set(file.id, info);\n            }\n\n            if (file.idb_key) {\n              info.idb_key = file.idb_key;\n              delete file.idb_key;\n            } else {\n              delete info.idb_key;\n            }\n\n            if (file.arr) {\n              var now = Date.now();\n\n              while (this.totalSize > 100000000) {\n                var node = this.lru.getLru(); // immunity for 60 seconds\n\n                if (node.usedAt + 60 * 1000 > now) {\n                  break;\n                }\n\n                var lru_info = this.cache.get(node.value);\n                this.unload(lru_info);\n              }\n\n              if (info.arr) {\n                logger.warn('Got file.arr at least twice for the same file');\n                this.totalSize -= info.arr.length;\n              }\n\n              info.arr = file.arr;\n              delete file.arr;\n              this.totalSize += info.arr.length;\n\n              if (!info.node) {\n                logger.debug('LRU: create file_id: ', file.id, ' with arr.length: ', info.arr.length);\n                info.node = new src_ListNode(file.id);\n              }\n\n              this.lru.onUsed(info.node);\n              logger.info('Total file.arr size: ', this.totalSize);\n            }\n\n            info.file = file;\n            return file;\n          }\n        }, {\n          key: \"flushLoad\",\n          value: function () {\n            var _flushLoad = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee5() {\n              var pending, idb, transaction_id, read, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;\n\n              return regenerator_default.a.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      pending = this.pending;\n                      this.pending = [];\n                      _context5.next = 4;\n                      return this.idb;\n\n                    case 4:\n                      idb = _context5.sent;\n                      transaction_id = this.transaction_id++;\n                      read = idb.transaction(['keyvaluepairs'], 'readonly').objectStore('keyvaluepairs');\n                      logger.debug('Load group of files from idb', pending.length);\n                      _iteratorNormalCompletion = true;\n                      _didIteratorError = false;\n                      _iteratorError = undefined;\n                      _context5.prev = 11;\n\n                      _loop = function _loop() {\n                        var query = _step.value;\n                        var request = read.get(query.key);\n\n                        request.onsuccess = function (event) {\n                          var blob = event.target.result;\n\n                          if (blob) {\n                            if (blob.size === 0) {\n                              logger.error('Got empty blob from db ', query.key);\n                            }\n\n                            query.resolve({\n                              data: blob,\n                              transaction_id: transaction_id\n                            });\n                          } else {\n                            query.reject();\n                          }\n                        };\n\n                        request.onerror = function () {\n                          return query.reject(request.error);\n                        };\n                      };\n\n                      for (_iterator = pending[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        _loop();\n                      }\n\n                      _context5.next = 20;\n                      break;\n\n                    case 16:\n                      _context5.prev = 16;\n                      _context5.t0 = _context5[\"catch\"](11);\n                      _didIteratorError = true;\n                      _iteratorError = _context5.t0;\n\n                    case 20:\n                      _context5.prev = 20;\n                      _context5.prev = 21;\n\n                      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                        _iterator[\"return\"]();\n                      }\n\n                    case 23:\n                      _context5.prev = 23;\n\n                      if (!_didIteratorError) {\n                        _context5.next = 26;\n                        break;\n                      }\n\n                      throw _iteratorError;\n\n                    case 26:\n                      return _context5.finish(23);\n\n                    case 27:\n                      return _context5.finish(20);\n\n                    case 28:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, this, [[11, 16, 20, 28], [21,, 23, 27]]);\n            }));\n\n            function flushLoad() {\n              return _flushLoad.apply(this, arguments);\n            }\n\n            return flushLoad;\n          }()\n        }, {\n          key: \"load\",\n          value: function load(key, resolve, reject) {\n            var _this6 = this;\n\n            if (this.pending.length === 0) {\n              setTimeout(function () {\n                _this6.flushLoad();\n              }, 1);\n            }\n\n            this.pending.push({\n              key: key,\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        }, {\n          key: \"doLoadFull\",\n          value: function () {\n            var _doLoadFull = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee6(info) {\n              var _this7 = this;\n\n              var idb_key;\n              return regenerator_default.a.wrap(function _callee6$(_context6) {\n                while (1) {\n                  switch (_context6.prev = _context6.next) {\n                    case 0:\n                      if (!info.arr) {\n                        _context6.next = 2;\n                        break;\n                      }\n\n                      return _context6.abrupt(\"return\", {\n                        data: new Blob([info.arr]),\n                        transaction_id: -1\n                      });\n\n                    case 2:\n                      if (!info.idb_key) {\n                        _context6.next = 7;\n                        break;\n                      }\n\n                      idb_key = info.idb_key; //return this.store.getItem(idb_key);\n\n                      _context6.next = 6;\n                      return new Promise(function (resolve, reject) {\n                        _this7.load(idb_key, resolve, reject);\n                      });\n\n                    case 6:\n                      return _context6.abrupt(\"return\", _context6.sent);\n\n                    case 7:\n                      throw new Error('File is not loaded');\n\n                    case 8:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }\n              }, _callee6);\n            }));\n\n            function doLoadFull(_x4) {\n              return _doLoadFull.apply(this, arguments);\n            }\n\n            return doLoadFull;\n          }()\n        }, {\n          key: \"doLoad\",\n          value: function () {\n            var _doLoad = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee7(info, offset, size) {\n              var count, _res, res, data_size;\n\n              return regenerator_default.a.wrap(function _callee7$(_context7) {\n                while (1) {\n                  switch (_context7.prev = _context7.next) {\n                    case 0:\n                      if (!(!info.arr && !info.idb_key && info.file.local.path)) {\n                        _context7.next = 24;\n                        break;\n                      }\n\n                      _context7.prev = 1;\n                      _context7.next = 4;\n                      return this.client.sendInternal({\n                        '@type': 'getFileDownloadedPrefixSize',\n                        file_id: info.file.id,\n                        offset: offset\n                      });\n\n                    case 4:\n                      count = _context7.sent;\n                      logger.error(count, size);\n\n                      if (size) {\n                        _context7.next = 10;\n                        break;\n                      }\n\n                      size = count.count;\n                      _context7.next = 12;\n                      break;\n\n                    case 10:\n                      if (!(size > count.count)) {\n                        _context7.next = 12;\n                        break;\n                      }\n\n                      throw new Error('File not loaded yet');\n\n                    case 12:\n                      _context7.next = 14;\n                      return this.client.sendInternal({\n                        '@type': 'readFilePart',\n                        path: info.file.local.path,\n                        offset: offset,\n                        size: size\n                      });\n\n                    case 14:\n                      _res = _context7.sent;\n                      _res.data = new Blob([_res.data]);\n                      _res.transaction_id = -2;\n                      logger.error(_res);\n                      return _context7.abrupt(\"return\", _res);\n\n                    case 21:\n                      _context7.prev = 21;\n                      _context7.t0 = _context7[\"catch\"](1);\n                      logger.info('readFilePart failed', info, offset, size, _context7.t0);\n\n                    case 24:\n                      _context7.next = 26;\n                      return this.doLoadFull(info);\n\n                    case 26:\n                      res = _context7.sent; // return slice(size, offset + size)\n\n                      data_size = res.data.size;\n\n                      if (!size) {\n                        size = data_size;\n                      }\n\n                      if (offset > data_size) {\n                        offset = data_size;\n                      }\n\n                      res.data = res.data.slice(offset, offset + size);\n                      return _context7.abrupt(\"return\", res);\n\n                    case 32:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }\n              }, _callee7, this, [[1, 21]]);\n            }));\n\n            function doLoad(_x5, _x6, _x7) {\n              return _doLoad.apply(this, arguments);\n            }\n\n            return doLoad;\n          }()\n        }, {\n          key: \"doDelete\",\n          value: function doDelete(info) {\n            this.unload(info);\n            return info.idb_key;\n          }\n        }, {\n          key: \"readFile\",\n          value: function () {\n            var _readFile2 = asyncToGenerator_default()(\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee8(query) {\n              var info, response;\n              return regenerator_default.a.wrap(function _callee8$(_context8) {\n                while (1) {\n                  switch (_context8.prev = _context8.next) {\n                    case 0:\n                      _context8.prev = 0;\n\n                      if (this.isInited) {\n                        _context8.next = 3;\n                        break;\n                      }\n\n                      throw new Error('FileManager is not inited');\n\n                    case 3:\n                      info = this.cache.get(query.file_id);\n\n                      if (info) {\n                        _context8.next = 6;\n                        break;\n                      }\n\n                      throw new Error('File is not loaded');\n\n                    case 6:\n                      if (info.node) {\n                        this.lru.onUsed(info.node);\n                      }\n\n                      query.offset = query.offset || 0;\n                      query.size = query.size || 0;\n                      _context8.next = 11;\n                      return this.doLoad(info, query.offset, query.size);\n\n                    case 11:\n                      response = _context8.sent;\n                      return _context8.abrupt(\"return\", {\n                        '@type': 'filePart',\n                        '@extra': query['@extra'],\n                        data: response.data,\n                        transaction_id: response.transaction_id\n                      });\n\n                    case 15:\n                      _context8.prev = 15;\n                      _context8.t0 = _context8[\"catch\"](0);\n                      return _context8.abrupt(\"return\", {\n                        '@type': 'error',\n                        '@extra': query['@extra'],\n                        code: 400,\n                        message: _context8.t0\n                      });\n\n                    case 18:\n                    case \"end\":\n                      return _context8.stop();\n                  }\n                }\n              }, _callee8, this, [[0, 15]]);\n            }));\n\n            function readFile(_x8) {\n              return _readFile2.apply(this, arguments);\n            }\n\n            return readFile;\n          }()\n        }, {\n          key: \"deleteFile\",\n          value: function deleteFile(query) {\n            var res = {\n              '@type': 'ok',\n              '@extra': query['@extra']\n            };\n\n            try {\n              if (!this.isInited) {\n                throw new Error('FileManager is not inited');\n              }\n\n              var info = this.cache.get(query.file_id);\n\n              if (!info) {\n                throw new Error('File is not loaded');\n              }\n\n              var idb_key = this.doDelete(info);\n\n              if (idb_key) {\n                res.idb_key = idb_key;\n              }\n            } catch (e) {}\n\n            return res;\n          }\n        }]);\n        return FileManager;\n      }();\n      /* harmony default export */\n\n\n      var src = __webpack_exports__[\"default\"] = src_TdClient;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}