{"ast":null,"code":"//https://stackoverflow.com/questions/183485/converting-punycode-with-dash-character-to-unicode\n//Javascript Punycode converter derived from example in RFC3492.\n//This implementation is created by some@domain.name and released into public domain\nfunction Punycode(){// This object converts to and from puny-code used in IDN\n//\n// punycode.ToASCII ( domain )\n//\n// Returns a puny coded representation of \"domain\".\n// It only converts the part of the domain name that\n// has non ASCII characters. I.e. it dosent matter if\n// you call it with a domain that already is in ASCII.\n//\n// punycode.ToUnicode (domain)\n//\n// Converts a puny-coded domain name to unicode.\n// It only converts the puny-coded parts of the domain name.\n// I.e. it dosent matter if you call it on a string\n// that already has been converted to unicode.\n//\n//\nthis.utf16={// The utf16-class is necessary to convert from javascripts internal character representation to unicode and back.\ndecode:function decode(input){var output=[],i=0,len=input.length,value,extra;while(i<len){value=input.charCodeAt(i++);if((value&0xf800)===0xd800){extra=input.charCodeAt(i++);if((value&0xfc00)!==0xd800||(extra&0xfc00)!==0xdc00){throw new RangeError('UTF-16(decode): Illegal UTF-16 sequence');}value=((value&0x3ff)<<10)+(extra&0x3ff)+0x10000;}output.push(value);}return output;},encode:function encode(input){var output=[],i=0,len=input.length,value;while(i<len){value=input[i++];if((value&0xf800)===0xd800){throw new RangeError('UTF-16(encode): Illegal UTF-16 value');}if(value>0xffff){value-=0x10000;output.push(String.fromCharCode(value>>>10&0x3ff|0xd800));value=0xdc00|value&0x3ff;}output.push(String.fromCharCode(value));}return output.join('');}};//Default parameters\nvar initial_n=0x80;var initial_bias=72;var delimiter='\\x2D';var base=36;var damp=700;var tmin=1;var tmax=26;var skew=38;var maxint=0x7fffffff;// decode_digit(cp) returns the numeric value of a basic code\n// point (for use in representing integers) in the range 0 to\n// base-1, or base if cp is does not represent a value.\nfunction decode_digit(cp){return cp-48<10?cp-22:cp-65<26?cp-65:cp-97<26?cp-97:base;}// encode_digit(d,flag) returns the basic code point whose value\n// (when used for representing integers) is d, which needs to be in\n// the range 0 to base-1. The lowercase form is used unless flag is\n// nonzero, in which case the uppercase form is used. The behavior\n// is undefined if flag is nonzero and digit d has no uppercase form.\nfunction encode_digit(d,flag){return d+22+75*(d<26)-((flag!=0)<<5);//  0..25 map to ASCII a..z or A..Z\n// 26..35 map to ASCII 0..9\n}//** Bias adaptation function **\nfunction adapt(delta,numpoints,firsttime){var k;delta=firsttime?Math.floor(delta/damp):delta>>1;delta+=Math.floor(delta/numpoints);for(k=0;delta>(base-tmin)*tmax>>1;k+=base){delta=Math.floor(delta/(base-tmin));}return Math.floor(k+(base-tmin+1)*delta/(delta+skew));}// encode_basic(bcp,flag) forces a basic code point to lowercase if flag is zero,\n// uppercase if flag is nonzero, and returns the resulting code point.\n// The code point is unchanged if it is caseless.\n// The behavior is undefined if bcp is not a basic code point.\nfunction encode_basic(bcp,flag){bcp-=(bcp-97<26)<<5;return bcp+((!flag&&bcp-65<26)<<5);}// Main decode\nthis.decode=function(input,preserveCase){// Dont use utf16\nvar output=[];var case_flags=[];var input_length=input.length;var n,out,i,bias,basic,j,ic,oldi,w,k,digit,t,len;// Initialize the state:\nn=initial_n;i=0;bias=initial_bias;// Handle the basic code points: Let basic be the number of input code\n// points before the last delimiter, or 0 if there is none, then\n// copy the first basic code points to the output.\nbasic=input.lastIndexOf(delimiter);if(basic<0)basic=0;for(j=0;j<basic;++j){if(preserveCase)case_flags[output.length]=input.charCodeAt(j)-65<26;if(input.charCodeAt(j)>=0x80){throw new RangeError('Illegal input >= 0x80');}output.push(input.charCodeAt(j));}// Main decoding loop: Start just after the last delimiter if any\n// basic code points were copied; start at the beginning otherwise.\nfor(ic=basic>0?basic+1:0;ic<input_length;){// ic is the index of the next character to be consumed,\n// Decode a generalized variable-length integer into delta,\n// which gets added to i. The overflow checking is easier\n// if we increase i as we go, then subtract off its starting\n// value at the end to obtain delta.\nfor(oldi=i,w=1,k=base;;k+=base){if(ic>=input_length){throw RangeError('punycode_bad_input(1)');}digit=decode_digit(input.charCodeAt(ic++));if(digit>=base){throw RangeError('punycode_bad_input(2)');}if(digit>Math.floor((maxint-i)/w)){throw RangeError('punycode_overflow(1)');}i+=digit*w;t=k<=bias?tmin:k>=bias+tmax?tmax:k-bias;if(digit<t){break;}if(w>Math.floor(maxint/(base-t))){throw RangeError('punycode_overflow(2)');}w*=base-t;}out=output.length+1;bias=adapt(i-oldi,out,oldi===0);// i was supposed to wrap around from out to 0,\n// incrementing n each time, so we'll fix that now:\nif(Math.floor(i/out)>maxint-n){throw RangeError('punycode_overflow(3)');}n+=Math.floor(i/out);i%=out;// Insert n at position i of the output:\n// Case of last character determines uppercase flag:\nif(preserveCase){case_flags.splice(i,0,input.charCodeAt(ic-1)-65<26);}output.splice(i,0,n);i++;}if(preserveCase){for(i=0,len=output.length;i<len;i++){if(case_flags[i]){output[i]=String.fromCharCode(output[i]).toUpperCase().charCodeAt(0);}}}return this.utf16.encode(output);};//** Main encode function **\nthis.encode=function(input,preserveCase){//** Bias adaptation function **\nvar n,delta,h,b,bias,j,m,q,k,t,ijv,case_flags;if(preserveCase){// Preserve case, step1 of 2: Get a list of the unaltered string\ncase_flags=this.utf16.decode(input);}// Converts the input in UTF-16 to Unicode\ninput=this.utf16.decode(input.toLowerCase());var input_length=input.length;// Cache the length\nif(preserveCase){// Preserve case, step2 of 2: Modify the list to true/false\nfor(j=0;j<input_length;j++){case_flags[j]=input[j]!=case_flags[j];}}var output=[];// Initialize the state:\nn=initial_n;delta=0;bias=initial_bias;// Handle the basic code points:\nfor(j=0;j<input_length;++j){if(input[j]<0x80){output.push(String.fromCharCode(case_flags?encode_basic(input[j],case_flags[j]):input[j]));}}h=b=output.length;// h is the number of code points that have been handled, b is the\n// number of basic code points\nif(b>0)output.push(delimiter);// Main encoding loop:\n//\nwhile(h<input_length){// All non-basic code points < n have been\n// handled already. Find the next larger one:\nfor(m=maxint,j=0;j<input_length;++j){ijv=input[j];if(ijv>=n&&ijv<m)m=ijv;}// Increase delta enough to advance the decoder's\n// <n,i> state to <m,0>, but guard against overflow:\nif(m-n>Math.floor((maxint-delta)/(h+1))){throw RangeError('punycode_overflow (1)');}delta+=(m-n)*(h+1);n=m;for(j=0;j<input_length;++j){ijv=input[j];if(ijv<n){if(++delta>maxint)return Error('punycode_overflow(2)');}if(ijv==n){// Represent delta as a generalized variable-length integer:\nfor(q=delta,k=base;;k+=base){t=k<=bias?tmin:k>=bias+tmax?tmax:k-bias;if(q<t)break;output.push(String.fromCharCode(encode_digit(t+(q-t)%(base-t),0)));q=Math.floor((q-t)/(base-t));}output.push(String.fromCharCode(encode_digit(q,preserveCase&&case_flags[j]?1:0)));bias=adapt(delta,h+1,h==b);delta=0;++h;}}++delta;++n;}return output.join('');};this.ToASCII=function(domain){var domain_array=domain.split('.');var out=[];for(var i=0;i<domain_array.length;++i){var s=domain_array[i];out.push(s.match(/[^A-Za-z0-9-]/)?'xn--'+punycode.encode(s):s);}return out.join('.');};this.ToUnicode=function(domain){var domain_array=domain.split('.');var out=[];for(var i=0;i<domain_array.length;++i){var s=domain_array[i];out.push(s.match(/^xn--/)?punycode.decode(s.slice(4)):s);}return out.join('.');};}var punycode=new Punycode();export default punycode;","map":{"version":3,"sources":["/home/me-admin/Downloads/my-app/src/Utils/Punycode.js"],"names":["Punycode","utf16","decode","input","output","i","len","length","value","extra","charCodeAt","RangeError","push","encode","String","fromCharCode","join","initial_n","initial_bias","delimiter","base","damp","tmin","tmax","skew","maxint","decode_digit","cp","encode_digit","d","flag","adapt","delta","numpoints","firsttime","k","Math","floor","encode_basic","bcp","preserveCase","case_flags","input_length","n","out","bias","basic","j","ic","oldi","w","digit","t","lastIndexOf","splice","toUpperCase","h","b","m","q","ijv","toLowerCase","Error","ToASCII","domain","domain_array","split","s","match","punycode","ToUnicode","slice"],"mappings":"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","sourcesContent":["//https://stackoverflow.com/questions/183485/converting-punycode-with-dash-character-to-unicode\n//Javascript Punycode converter derived from example in RFC3492.\n//This implementation is created by some@domain.name and released into public domain\nfunction Punycode() {\n    // This object converts to and from puny-code used in IDN\n    //\n    // punycode.ToASCII ( domain )\n    //\n    // Returns a puny coded representation of \"domain\".\n    // It only converts the part of the domain name that\n    // has non ASCII characters. I.e. it dosent matter if\n    // you call it with a domain that already is in ASCII.\n    //\n    // punycode.ToUnicode (domain)\n    //\n    // Converts a puny-coded domain name to unicode.\n    // It only converts the puny-coded parts of the domain name.\n    // I.e. it dosent matter if you call it on a string\n    // that already has been converted to unicode.\n    //\n    //\n    this.utf16 = {\n        // The utf16-class is necessary to convert from javascripts internal character representation to unicode and back.\n        decode: function(input) {\n            var output = [],\n                i = 0,\n                len = input.length,\n                value,\n                extra;\n            while (i < len) {\n                value = input.charCodeAt(i++);\n                if ((value & 0xf800) === 0xd800) {\n                    extra = input.charCodeAt(i++);\n                    if ((value & 0xfc00) !== 0xd800 || (extra & 0xfc00) !== 0xdc00) {\n                        throw new RangeError('UTF-16(decode): Illegal UTF-16 sequence');\n                    }\n                    value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                }\n                output.push(value);\n            }\n            return output;\n        },\n        encode: function(input) {\n            var output = [],\n                i = 0,\n                len = input.length,\n                value;\n            while (i < len) {\n                value = input[i++];\n                if ((value & 0xf800) === 0xd800) {\n                    throw new RangeError('UTF-16(encode): Illegal UTF-16 value');\n                }\n                if (value > 0xffff) {\n                    value -= 0x10000;\n                    output.push(String.fromCharCode(((value >>> 10) & 0x3ff) | 0xd800));\n                    value = 0xdc00 | (value & 0x3ff);\n                }\n                output.push(String.fromCharCode(value));\n            }\n            return output.join('');\n        }\n    };\n\n    //Default parameters\n    var initial_n = 0x80;\n    var initial_bias = 72;\n    var delimiter = '\\x2D';\n    var base = 36;\n    var damp = 700;\n    var tmin = 1;\n    var tmax = 26;\n    var skew = 38;\n    var maxint = 0x7fffffff;\n\n    // decode_digit(cp) returns the numeric value of a basic code\n    // point (for use in representing integers) in the range 0 to\n    // base-1, or base if cp is does not represent a value.\n\n    function decode_digit(cp) {\n        return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : cp - 97 < 26 ? cp - 97 : base;\n    }\n\n    // encode_digit(d,flag) returns the basic code point whose value\n    // (when used for representing integers) is d, which needs to be in\n    // the range 0 to base-1. The lowercase form is used unless flag is\n    // nonzero, in which case the uppercase form is used. The behavior\n    // is undefined if flag is nonzero and digit d has no uppercase form.\n\n    function encode_digit(d, flag) {\n        return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n    }\n    //** Bias adaptation function **\n    function adapt(delta, numpoints, firsttime) {\n        var k;\n        delta = firsttime ? Math.floor(delta / damp) : delta >> 1;\n        delta += Math.floor(delta / numpoints);\n\n        for (k = 0; delta > ((base - tmin) * tmax) >> 1; k += base) {\n            delta = Math.floor(delta / (base - tmin));\n        }\n        return Math.floor(k + ((base - tmin + 1) * delta) / (delta + skew));\n    }\n\n    // encode_basic(bcp,flag) forces a basic code point to lowercase if flag is zero,\n    // uppercase if flag is nonzero, and returns the resulting code point.\n    // The code point is unchanged if it is caseless.\n    // The behavior is undefined if bcp is not a basic code point.\n\n    function encode_basic(bcp, flag) {\n        bcp -= (bcp - 97 < 26) << 5;\n        return bcp + ((!flag && bcp - 65 < 26) << 5);\n    }\n\n    // Main decode\n    this.decode = function(input, preserveCase) {\n        // Dont use utf16\n        var output = [];\n        var case_flags = [];\n        var input_length = input.length;\n\n        var n, out, i, bias, basic, j, ic, oldi, w, k, digit, t, len;\n\n        // Initialize the state:\n\n        n = initial_n;\n        i = 0;\n        bias = initial_bias;\n\n        // Handle the basic code points: Let basic be the number of input code\n        // points before the last delimiter, or 0 if there is none, then\n        // copy the first basic code points to the output.\n\n        basic = input.lastIndexOf(delimiter);\n        if (basic < 0) basic = 0;\n\n        for (j = 0; j < basic; ++j) {\n            if (preserveCase) case_flags[output.length] = input.charCodeAt(j) - 65 < 26;\n            if (input.charCodeAt(j) >= 0x80) {\n                throw new RangeError('Illegal input >= 0x80');\n            }\n            output.push(input.charCodeAt(j));\n        }\n\n        // Main decoding loop: Start just after the last delimiter if any\n        // basic code points were copied; start at the beginning otherwise.\n\n        for (ic = basic > 0 ? basic + 1 : 0; ic < input_length; ) {\n            // ic is the index of the next character to be consumed,\n\n            // Decode a generalized variable-length integer into delta,\n            // which gets added to i. The overflow checking is easier\n            // if we increase i as we go, then subtract off its starting\n            // value at the end to obtain delta.\n            for (oldi = i, w = 1, k = base; ; k += base) {\n                if (ic >= input_length) {\n                    throw RangeError('punycode_bad_input(1)');\n                }\n                digit = decode_digit(input.charCodeAt(ic++));\n\n                if (digit >= base) {\n                    throw RangeError('punycode_bad_input(2)');\n                }\n                if (digit > Math.floor((maxint - i) / w)) {\n                    throw RangeError('punycode_overflow(1)');\n                }\n                i += digit * w;\n                t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                if (w > Math.floor(maxint / (base - t))) {\n                    throw RangeError('punycode_overflow(2)');\n                }\n                w *= base - t;\n            }\n\n            out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi === 0);\n\n            // i was supposed to wrap around from out to 0,\n            // incrementing n each time, so we'll fix that now:\n            if (Math.floor(i / out) > maxint - n) {\n                throw RangeError('punycode_overflow(3)');\n            }\n            n += Math.floor(i / out);\n            i %= out;\n\n            // Insert n at position i of the output:\n            // Case of last character determines uppercase flag:\n            if (preserveCase) {\n                case_flags.splice(i, 0, input.charCodeAt(ic - 1) - 65 < 26);\n            }\n\n            output.splice(i, 0, n);\n            i++;\n        }\n        if (preserveCase) {\n            for (i = 0, len = output.length; i < len; i++) {\n                if (case_flags[i]) {\n                    output[i] = String.fromCharCode(output[i])\n                        .toUpperCase()\n                        .charCodeAt(0);\n                }\n            }\n        }\n        return this.utf16.encode(output);\n    };\n\n    //** Main encode function **\n\n    this.encode = function(input, preserveCase) {\n        //** Bias adaptation function **\n\n        var n, delta, h, b, bias, j, m, q, k, t, ijv, case_flags;\n\n        if (preserveCase) {\n            // Preserve case, step1 of 2: Get a list of the unaltered string\n            case_flags = this.utf16.decode(input);\n        }\n        // Converts the input in UTF-16 to Unicode\n        input = this.utf16.decode(input.toLowerCase());\n\n        var input_length = input.length; // Cache the length\n\n        if (preserveCase) {\n            // Preserve case, step2 of 2: Modify the list to true/false\n            for (j = 0; j < input_length; j++) {\n                case_flags[j] = input[j] != case_flags[j];\n            }\n        }\n\n        var output = [];\n\n        // Initialize the state:\n        n = initial_n;\n        delta = 0;\n        bias = initial_bias;\n\n        // Handle the basic code points:\n        for (j = 0; j < input_length; ++j) {\n            if (input[j] < 0x80) {\n                output.push(String.fromCharCode(case_flags ? encode_basic(input[j], case_flags[j]) : input[j]));\n            }\n        }\n\n        h = b = output.length;\n\n        // h is the number of code points that have been handled, b is the\n        // number of basic code points\n\n        if (b > 0) output.push(delimiter);\n\n        // Main encoding loop:\n        //\n        while (h < input_length) {\n            // All non-basic code points < n have been\n            // handled already. Find the next larger one:\n\n            for (m = maxint, j = 0; j < input_length; ++j) {\n                ijv = input[j];\n                if (ijv >= n && ijv < m) m = ijv;\n            }\n\n            // Increase delta enough to advance the decoder's\n            // <n,i> state to <m,0>, but guard against overflow:\n\n            if (m - n > Math.floor((maxint - delta) / (h + 1))) {\n                throw RangeError('punycode_overflow (1)');\n            }\n            delta += (m - n) * (h + 1);\n            n = m;\n\n            for (j = 0; j < input_length; ++j) {\n                ijv = input[j];\n\n                if (ijv < n) {\n                    if (++delta > maxint) return Error('punycode_overflow(2)');\n                }\n\n                if (ijv == n) {\n                    // Represent delta as a generalized variable-length integer:\n                    for (q = delta, k = base; ; k += base) {\n                        t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;\n                        if (q < t) break;\n                        output.push(String.fromCharCode(encode_digit(t + ((q - t) % (base - t)), 0)));\n                        q = Math.floor((q - t) / (base - t));\n                    }\n                    output.push(String.fromCharCode(encode_digit(q, preserveCase && case_flags[j] ? 1 : 0)));\n                    bias = adapt(delta, h + 1, h == b);\n                    delta = 0;\n                    ++h;\n                }\n            }\n\n            ++delta;\n            ++n;\n        }\n        return output.join('');\n    };\n\n    this.ToASCII = function(domain) {\n        var domain_array = domain.split('.');\n        var out = [];\n        for (var i = 0; i < domain_array.length; ++i) {\n            var s = domain_array[i];\n            out.push(s.match(/[^A-Za-z0-9-]/) ? 'xn--' + punycode.encode(s) : s);\n        }\n        return out.join('.');\n    };\n    this.ToUnicode = function(domain) {\n        var domain_array = domain.split('.');\n        var out = [];\n        for (var i = 0; i < domain_array.length; ++i) {\n            var s = domain_array[i];\n            out.push(s.match(/^xn--/) ? punycode.decode(s.slice(4)) : s);\n        }\n        return out.join('.');\n    };\n}\n\nconst punycode = new Punycode();\nexport default punycode;\n"]},"metadata":{},"sourceType":"module"}